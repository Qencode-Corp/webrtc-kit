{"version":3,"file":"QencodeWebRTC.min.js","mappings":"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","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const QencodeWebRTC = {};\n\nconst logHeader = 'QencodeWebRTC.js :';\nconst logEventHeader = 'QencodeWebRTC.js :';\n\n// private methods\nfunction sendMessage(webSocket, message) {\n    if (webSocket) {\n        webSocket.send(JSON.stringify(message));\n    }\n}\n\nfunction generateDomainFromUrl(url) {\n    let result = '';\n    let match;\n    if (match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im)) {\n        result = match[1];\n    }\n\n    return result;\n}\n\nfunction findIp(string) {\n    let result = '';\n    let match;\n\n    if (match = string.match(new RegExp('\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b', 'gi'))) {\n        result = match[0];\n    }\n\n    return result;\n}\n\nfunction checkIOSVersion() {\n    var agent = window.navigator.userAgent,\n        start = agent.indexOf('OS ');\n    if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\n        return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\n    }\n    return 0;\n}\n\n// SDP helper functions to properly handle CRLF line endings (RFC 4566)\nfunction splitSdpLines(sdp) {\n    // Normalize line endings: split on \\r\\n or \\n, and remove trailing \\r from each line\n    return sdp.split(/\\r?\\n/).map(line => line.replace(/\\r$/, ''));\n}\n\nfunction joinSdpLines(lines) {\n    // Join with CRLF as required by SDP specification (RFC 4566)\n    return lines.join('\\r\\n');\n}\n\nfunction getFormatNumber(sdp, format) {\n    const lines = splitSdpLines(sdp);\n    let formatNumber = -1;\n\n    for (let i = 0; i < lines.length - 1; i++) {\n        lines[i] = lines[i].toLowerCase();\n\n        if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\n            // parsing \"a=rtpmap:100 H264/90000\" line\n            formatNumber = lines[i].split(' ')[0].split(':')[1];\n            break;\n        }\n    }\n\n    return formatNumber;\n}\n\nfunction removeFormat(sdp, formatNumber) {\n    let newLines = [];\n    let lines = splitSdpLines(sdp);\n\n    for (let i = 0; i < lines.length; i++) {\n\n        if (lines[i].indexOf('m=video') === 0) {\n            newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\n        } else if (lines[i].indexOf(formatNumber + '') > -1) {\n\n        } else {\n            newLines.push(lines[i]);\n        }\n    }\n\n    return joinSdpLines(newLines)\n}\n\nasync function getStreamForDeviceCheck() {\n    // High resolution video constraints makes browser to get maximum resolution of video device.\n    const constraints = {\n        audio: { deviceId: undefined },\n        video: { deviceId: undefined, width: 1920, height: 1080 }\n    };\n\n    return await navigator.mediaDevices.getUserMedia(constraints);\n}\n\nasync function getDevices() {\n    return await navigator.mediaDevices.enumerateDevices();\n}\n\nfunction gotDevices(deviceInfos) {\n\n    let devices = {\n        'audioinput': [],\n        'audiooutput': [],\n        'videoinput': [],\n        'other': [],\n    };\n\n    for (let i = 0; i !== deviceInfos.length; ++i) {\n\n        const deviceInfo = deviceInfos[i];\n\n        let info = {};\n\n        info.deviceId = deviceInfo.deviceId;\n\n        if (deviceInfo.kind === 'audioinput') {\n\n            info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\n            devices.audioinput.push(info);\n        } else if (deviceInfo.kind === 'audiooutput') {\n\n            info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\n            devices.audiooutput.push(info);\n        } else if (deviceInfo.kind === 'videoinput') {\n\n            info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\n            devices.videoinput.push(info);\n        } else {\n\n            info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\n            devices.other.push(info);\n        }\n    }\n\n    return devices;\n}\n\nfunction initConfig(instance) {\n    instance.connectionConfig = {};\n    instance.connectionUrl = null;\n    instance.createPeerConnectionCount = 0;\n    instance.error = null;\n    instance.offerRequestCount = 0;\n    instance.peerConnection = null;\n    instance.retriesUsed = 0;\n    instance.stream = null;\n    instance.videoElement = null;\n    instance.webSocket = null;\n    instance.webSocketCloseEvent = null;\n}\n\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nfunction waitForOnline() {\n  if (navigator.onLine) {\n    console.log('already online')\n    return Promise.resolve()\n  };\n  \n  return new Promise((resolve) => {\n    console.log(\"Offline. Waiting for connection...\");\n    // Use { once: true } to auto-remove the listener after it fires\n    window.addEventListener('online', () => {\n      console.log(\"Back online!\");\n      resolve();\n    }, { once: true });\n  });\n}\n\nfunction delayedCall(fn, args, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      Promise.resolve(fn(...args)).then(resolve);\n    }, delay);\n  });\n}\n\n// From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\nfunction setBitrateLimit(sdp, media, bitrate) {\n  \n  let lines = splitSdpLines(sdp);\n  let line = -1;\n  \n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=' + media) === 0) {\n      line = i;\n      break;\n    }\n  }\n  if (line === -1) {\n    // Could not find the m line for media\n    return sdp;\n  }\n  \n  // Pass the m line\n  line++;\n  \n  // Skip i and c lines\n  while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\n    \n    line++;\n  }\n  \n  // If we're on a b line, replace it\n  if (lines[line].indexOf('b') === 0) {\n    \n    lines[line] = 'b=AS:' + bitrate;\n    \n    return joinSdpLines(lines);\n  }\n  \n  // Add a new b line\n  let newLines = lines.slice(0, line)\n  \n  newLines.push('b=AS:' + bitrate)\n  newLines = newLines.concat(lines.slice(line, lines.length))\n  \n  return joinSdpLines(newLines)\n}\n\nfunction appendFmtp(fmtpStr, sdp) {\n  const lines = splitSdpLines(sdp);\n  const payloads = [];\n  \n  for (let i = 0; i < lines.length; i++) {\n    \n    if (lines[i].indexOf('m=video') === 0) {\n      \n      let tokens = lines[i].split(' ')\n      \n      for (let j = 3; j < tokens.length; j++) {\n        \n        payloads.push(tokens[j]);\n      }\n      \n      break;\n    }\n  }\n  \n  for (let i = 0; i < payloads.length; i++) {\n    \n    let fmtpLineFound = false;\n    \n    for (let j = 0; j < lines.length; j++) {\n      \n      if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\n        fmtpLineFound = true;\n        lines[j] += ';' + fmtpStr;\n      }\n    }\n    \n    if (!fmtpLineFound) {\n      \n      for (let j = 0; j < lines.length; j++) {\n        \n        if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\n          \n          lines[j] += '\\r\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\n        }\n      }\n    }\n  }\n  \n  return joinSdpLines(lines)\n}\n\nfunction addMethod(instance) {\n\n    function errorHandler(error) {\n        instance.error = error;\n    }\n\n    function getUserMedia(constraints) {\n        if (!constraints) {\n            constraints = {\n                video: {\n                    deviceId: undefined\n                },\n                audio: {\n                    deviceId: undefined\n                }\n            };\n        }\n        \n        return navigator.mediaDevices.getUserMedia(constraints)\n            .then(function (stream) {\n                console.info(logHeader, 'Received Media Stream From Input Device', stream);\n                instance.stream = stream;\n                let elem = instance.videoElement;\n\n                // Attach stream to video element when video element is provided.\n                if (elem) {\n                    elem.srcObject = stream;\n                    elem.onloadedmetadata = function (e) {\n                        elem.play();\n                    };\n                }\n\n                return new Promise(function (resolve) {\n                    resolve(stream);\n                });\n            })\n            .catch(function (error) {\n                console.error(logHeader, 'Can\\'t Get Media Stream From Input Device', error);\n                errorHandler(error);\n\n                return new Promise(function (resolve, reject) {\n                    reject(error);\n                });\n            });\n    }\n\n    function getDisplayMedia(constraints) {\n        if (!constraints) {\n            constraints = {};\n        }\n\n        return navigator.mediaDevices.getDisplayMedia(constraints)\n            .then(function (stream) {\n                console.info(logHeader, 'Received Media Stream From Display', stream);\n                instance.stream = stream;\n                let elem = instance.videoElement;\n\n                // Attach stream to video element when video element is provided.\n                if (elem) {\n                    elem.srcObject = stream;\n                    elem.onloadedmetadata = function (e) {\n                        elem.play();\n                    };\n                }\n\n                return new Promise(function (resolve) {\n                    resolve(stream);\n                });\n            })\n            .catch(function (error) {\n                console.error(logHeader, 'Can\\'t Get Media Stream From Display', error);\n                errorHandler(error);\n\n                return new Promise(function (resolve, reject) {\n                    reject(error);\n                });\n            });\n    }\n    \n    function initWebSocket(connectionUrl) {\n        if (!connectionUrl) {\n            errorHandler('connectionUrl is required');\n            return;\n        }\n\n        instance.connectionUrl = connectionUrl;\n\n        let webSocket = null;\n        try {\n            webSocket = new WebSocket(connectionUrl);\n        } catch (error) {\n            errorHandler(error);\n            return;\n        }\n        \n        instance.webSocket = webSocket;\n        \n        function requestOffer() {\n          sendMessage(instance.webSocket, {\n            command: 'request_offer'\n          });\n          instance.offerRequestCount += 1;\n        }\n\n        webSocket.onopen = function () {\n          instance.retriesUsed = 0;\n          instance.offerRequestCount = 0;\n          requestOffer();\n        };\n\n        webSocket.onmessage = async function (e) {\n            let message = JSON.parse(e.data);\n\n            if (message.error) {\n                console.error('webSocket.onmessage', message.error);\n                errorHandler(message.error);\n                instance.reconnectWebSocketPromise = delayedCall(reconnectWebSocket, [], instance.retryDelay); /* Runs in cases like switching Wi-Fi networks. */\n                await instance.reconnectWebSocketPromise;\n                return;\n            }\n\n            if (message.command === 'offer') {\n                // OME returns offer. Start create peer connection.\n                try {\n                  await createPeerConnection(\n                    message.id,\n                    message.peer_id,\n                    message.sdp,\n                    message.candidates,\n                    message.ice_servers\n                  );\n                  instance.createPeerConnectionCount += 1; // todo understand why is this and why it's not reset\n                  instance.offerRequestCount = 0;\n                } catch (e) {\n                  console.log('createPeerConnection error', e);\n                  \n                  if (instance.offerRequestCount < 3) {\n                    requestOffer();\n                  } else {\n                    instance.reconnectWebSocketPromise = delayedCall(reconnectWebSocket, [], instance.retryDelay)\n                    await instance.reconnectWebSocketPromise;\n                  }\n                }\n            }\n        };\n        \n        async function reconnectWebSocket() {\n          await waitForOnline();\n          \n          if (instance.reconnectWebSocketPromise) {\n            await instance.reconnectWebSocketPromise;\n          }\n\n          const promise = new Promise(async function (resolve) {\n            if (\n              Number.isFinite(instance.retryDelay) &&\n              Number.isFinite(instance.retryMaxCount) &&\n              instance.retriesUsed < instance.retryMaxCount\n            ) {\n              instance.retriesUsed += 1;\n              console.info(`online=${navigator.onLine}. Starting retry attempt ${instance.retriesUsed}`);\n              \n              // Close the failed WebSocket before retrying\n              if (instance.webSocket && instance.webSocket.readyState !== WebSocket.CLOSED) {\n                instance.webSocket.onerror = null; // Remove handlers to prevent stale events\n                instance.webSocket.onclose = null;\n                instance.webSocket.onmessage = null;\n                instance.webSocket.onopen = null;\n                instance.webSocket.close();\n              }\n              instance.error = null;\n              instance.webSocketCloseEvent = null;\n              instance.peerConnection = null;\n              \n              \n              try {\n                await delayedCall(initWebSocket, [connectionUrl], instance.retryDelay);\n              } catch (e) {\n              \n              } finally {\n                resolve();\n              }\n              \n            }\n            resolve();\n          });\n          \n          return promise;\n        }\n        \n        /* For reliability it is recommended to check for error with event code in onclose instead. */\n        webSocket.onerror = (e) => console.log('webSocket.onerror', e);\n\n        webSocket.onclose = async function (event) {\n            console.log('Connection closed', event);\n            instance.webSocketCloseEvent = event;\n            // Check if the close was clean (1000) or caused by an issue\n            if (event.code !== 1000) {\n              await waitForOnline();\n              instance.reconnectWebSocketPromise = delayedCall(reconnectWebSocket, [], instance.retryDelay)\n              await instance.reconnectWebSocketPromise;\n            } else {\n              console.log(\"Connection closed normally.\");\n            }\n        };\n    }\n    \n    async function createPeerConnection(id, peerId, offer, candidates, iceServers) {\n        window.connectionData = {\n            id,\n            peerId\n        }\n\n        let peerConnectionConfig = {};\n\n        if (instance.connectionConfig.iceServers) {\n\n            // first priority using ice servers from local config.\n            peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\n\n            if (instance.connectionConfig.iceTransportPolicy) {\n\n                peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\n            }\n        } else if (iceServers) {\n\n            // second priority using ice servers from ome and force using TCP\n            peerConnectionConfig.iceServers = [];\n\n            for (let i = 0; i < iceServers.length; i++) {\n                let iceServer = iceServers[i];\n                let regIceServer = {};\n                regIceServer.urls = iceServer.urls;\n                let hasWebSocketUrl = false;\n                let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\n\n                for (let j = 0; j < regIceServer.urls.length; j++) {\n                    let serverUrl = regIceServer.urls[j];\n                    \n                    if (serverUrl.indexOf(webSocketUrl) > -1) {\n                        hasWebSocketUrl = true;\n                        break;\n                    }\n                }\n\n                if (!hasWebSocketUrl) {\n                    if (regIceServer.urls.length > 0) {\n                        let cloneIceServer = regIceServer.urls[0];\n                        let ip = findIp(cloneIceServer);\n\n                        if (webSocketUrl && ip) {\n                            regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\n                        }\n                    }\n                }\n\n                regIceServer.username = iceServer.user_name;\n                regIceServer.credential = iceServer.credential;\n                peerConnectionConfig.iceServers.push(regIceServer);\n            }\n\n            peerConnectionConfig.iceTransportPolicy = 'relay';\n        } else {\n            // last priority using default ice servers.\n            if (instance.iceTransportPolicy) {\n                peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\n            }\n        }\n        \n        console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\n\n        let peerConnection = new RTCPeerConnection(peerConnectionConfig);\n        instance.peerConnection = peerConnection;\n\n        // set local stream\n        instance.stream.getTracks().forEach(function (track) {\n            console.info(logHeader, 'Add Track To Peer Connection', track);\n            peerConnection.addTrack(track, instance.stream);\n        });\n\n\n        if (checkIOSVersion() >= 15) {\n            const formatNumber = getFormatNumber(offer.sdp, 'H264');\n\n            if (formatNumber > 0) {\n                offer.sdp = removeFormat(offer.sdp, formatNumber);\n            }\n        }\n\n        if (instance.connectionConfig.maxVideoBitrate) {\n            // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\n            offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\n        }\n\n        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n            offer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, offer.sdp);\n        }\n        \n        \n      // Set up event handlers BEFORE setRemoteDescription to avoid missing events\n      peerConnection.onicecandidate = function (e) {\n            if (e.candidate && e.candidate.candidate) {\n                // console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\n                sendMessage(instance.webSocket, {\n                    id: id,\n                    peer_id: peerId,\n                    command: 'candidate',\n                    candidates: [e.candidate]\n                });\n            }\n        };\n\n      peerConnection.oniceconnectionstatechange = function (e) {\n          let state = peerConnection.iceConnectionState;\n\n          console.info(logHeader, 'ICE State', '[' + state + ']');\n          instance.iceLastEvent = e;\n      };\n\n      peerConnection.onconnectionstatechange = function (e) {\n          let state = peerConnection.connectionState;\n\n          if (state === 'connected') {\n            instance.error = null;\n            instance.webSocketCloseEvent = null;\n            instance.reconnectWebSocketPromise = null;\n          }\n      };\n\n      await peerConnection.setRemoteDescription(offer);\n      const answer = await peerConnection.createAnswer();\n\n      if (checkIOSVersion() >= 15) {\n          const formatNumber = getFormatNumber(answer.sdp, 'H264');\n          \n          if (formatNumber > 0) {\n              answer.sdp = removeFormat(answer.sdp, formatNumber);\n          }\n      }\n\n      if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n          answer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, answer.sdp);\n      }\n\n      await peerConnection.setLocalDescription(answer);\n      \n      // Add remote ICE candidates after setRemoteDescription completes\n      if (candidates) {\n          await addIceCandidate(peerConnection, candidates);\n      }\n      \n      sendMessage(instance.webSocket, {\n          id: id,\n          peer_id: peerId,\n          command: 'answer',\n          sdp: answer\n      });\n    }\n\n    async function addIceCandidate(peerConnection, candidates) {\n        for (let i = 0; i < candidates.length; i++) {\n\n            if (candidates[i] && candidates[i].candidate) {\n                let basicCandidate = candidates[i];\n\n                try {\n                    await peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate));\n                } catch (error) {\n                    console.error('peerConnection.addIceCandidate', basicCandidate, error);\n                    errorHandler(error);\n                }\n            }\n        }\n    }\n\n    // instance methods\n    instance.attachMedia = function (videoElement) {\n        instance.videoElement = videoElement;\n    };\n\n    instance.getUserMedia = function (constraints) {\n        return getUserMedia(constraints);\n    };\n\n    instance.getDisplayMedia = function (constraints) {\n        return getDisplayMedia(constraints);\n    };\n\n    instance.startStreaming = function (connectionUrl, connectionConfig) {\n        connectionUrl+=\"?direction=send&transport=tcp\"\n        console.info(logEventHeader, 'Start Streaming');\n\n        if (connectionConfig) {\n            instance.connectionConfig = connectionConfig;\n        }\n        \n        instance.retriesUsed = 0;\n        initWebSocket(connectionUrl);\n    };\n\n    instance.remove = function () {\n\n        // first release peer connection with ome\n        if (instance.peerConnection) {\n            // remove tracks from peer connection\n            instance.peerConnection.getSenders().forEach(function (sender) {\n                instance.peerConnection.removeTrack(sender);\n            });\n\n            instance.peerConnection.close();\n            instance.peerConnection = null;\n            delete instance.peerConnection;\n        }\n\n        // release video, audio stream\n        if (instance.stream) {\n            instance.stream.getTracks().forEach(track => {\n                track.stop();\n                instance.stream.removeTrack(track);\n            });\n\n            if (instance.videoElement) {\n                instance.videoElement.srcObject = null;\n            }\n\n            instance.stream = null;\n            delete instance.stream;\n        }\n\n        // release websocket\n        if (instance.webSocket) {\n            sendMessage(instance.webSocket, {\n                id: window.connectionData.id,\n                peer_id: window.connectionData.peerId,\n                command: 'stop',\n            });\n\n            instance.webSocket.close();\n            instance.webSocket = null;\n            delete instance.webSocket;\n        }\n\n        console.info(logEventHeader, 'Removed');\n    };\n}\n\n// static methods\nQencodeWebRTC.create = function () {\n    let instance = {\n      retryMaxCount: 2,\n      retryDelay: 2000,\n    };\n\n    initConfig(instance);\n    addMethod(instance);\n\n    return instance;\n};\n\nQencodeWebRTC.getDevices = async function () {\n    await getStreamForDeviceCheck();\n    const deviceInfos = await getDevices();\n    return gotDevices(deviceInfos)\n};\n\nexport default QencodeWebRTC;"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","sendMessage","webSocket","message","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","checkIOSVersion","agent","window","navigator","userAgent","start","indexOf","Number","substr","replace","splitSdpLines","sdp","split","map","line","joinSdpLines","lines","join","getFormatNumber","format","formatNumber","i","length","toLowerCase","removeFormat","newLines","push","waitForOnline","onLine","console","log","Promise","resolve","addEventListener","once","delayedCall","fn","args","delay","setTimeout","then","appendFmtp","fmtpStr","payloads","tokens","j","fmtpLineFound","create","instance","retryMaxCount","retryDelay","connectionConfig","connectionUrl","createPeerConnectionCount","error","offerRequestCount","peerConnection","retriesUsed","stream","videoElement","webSocketCloseEvent","initConfig","errorHandler","initWebSocket","WebSocket","requestOffer","command","async","reconnectWebSocket","reconnectWebSocketPromise","isFinite","info","readyState","CLOSED","onerror","onclose","onmessage","onopen","close","e","parse","data","id","peerId","offer","candidates","iceServers","connectionData","peerConnectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","getTracks","forEach","track","addTrack","maxVideoBitrate","media","bitrate","slice","concat","setBitrateLimit","onicecandidate","candidate","peer_id","oniceconnectionstatechange","state","iceConnectionState","iceLastEvent","onconnectionstatechange","connectionState","setRemoteDescription","answer","createAnswer","setLocalDescription","basicCandidate","addIceCandidate","RTCIceCandidate","createPeerConnection","ice_servers","event","code","attachMedia","getUserMedia","constraints","video","deviceId","undefined","audio","mediaDevices","elem","srcObject","onloadedmetadata","play","catch","reject","getDisplayMedia","startStreaming","remove","getSenders","sender","removeTrack","stop","addMethod","getDevices","width","height","getStreamForDeviceCheck","deviceInfos","devices","deviceInfo","kind","label","audioinput","audiooutput","videoinput","other","gotDevices","enumerateDevices"],"sourceRoot":""}