{"version":3,"file":"QencodeWebRTC.min.js","mappings":"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","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const QencodeWebRTC = {};\r\n\r\nconst logHeader = 'QencodeWebRTC.js :';\r\nconst logEventHeader = 'QencodeWebRTC.js :';\r\n\r\nlet pendingRemoteCandidates = [];\r\nlet remoteDescriptionSet = false;\r\n\r\n// private methods\r\nfunction sendMessage(webSocket, message) {\r\n\r\n    if (webSocket) {\r\n        webSocket.send(JSON.stringify(message));\r\n    }\r\n}\r\n\r\nfunction generateDomainFromUrl(url) {\r\n    let result = '';\r\n    let match;\r\n    if (match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im)) {\r\n        result = match[1];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction findIp(string) {\r\n\r\n    let result = '';\r\n    let match;\r\n\r\n    if (match = string.match(new RegExp('\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b', 'gi'))) {\r\n        result = match[0];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction checkIOSVersion() {\r\n    var agent = window.navigator.userAgent,\r\n        start = agent.indexOf('OS ');\r\n    if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\r\n        return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction getFormatNumber(sdp, format) {\r\n\r\n    const lines = sdp.split('\\n');\r\n    let formatNumber = -1;\r\n\r\n    for (let i = 0; i < lines.length - 1; i++) {\r\n\r\n        lines[i] = lines[i].toLowerCase();\r\n\r\n        if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\r\n            // parsing \"a=rtpmap:100 H264/90000\" line\r\n            formatNumber = lines[i].split(' ')[0].split(':')[1];\r\n            break;\r\n        }\r\n    }\r\n\r\n    return formatNumber;\r\n}\r\n\r\nfunction removeFormat(sdp, formatNumber) {\r\n    let newLines = [];\r\n    let lines = sdp.split('\\n');\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n\r\n        if (lines[i].indexOf('m=video') === 0) {\r\n            newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\r\n        } else if (lines[i].indexOf(formatNumber + '') > -1) {\r\n\r\n        } else {\r\n            newLines.push(lines[i]);\r\n        }\r\n    }\r\n\r\n    return newLines.join('\\n')\r\n}\r\n\r\nasync function getStreamForDeviceCheck() {\r\n\r\n    // High resolution video constraints makes browser to get maximum resolution of video device.\r\n    const constraints = {\r\n        audio: { deviceId: undefined },\r\n        video: { deviceId: undefined, width: 1920, height: 1080 }\r\n    };\r\n\r\n    return await navigator.mediaDevices.getUserMedia(constraints);\r\n}\r\n\r\nasync function getDevices() {\r\n\r\n    return await navigator.mediaDevices.enumerateDevices();\r\n\r\n\r\n}\r\n\r\nfunction gotDevices(deviceInfos) {\r\n\r\n    let devices = {\r\n        'audioinput': [],\r\n        'audiooutput': [],\r\n        'videoinput': [],\r\n        'other': [],\r\n    };\r\n\r\n    for (let i = 0; i !== deviceInfos.length; ++i) {\r\n\r\n        const deviceInfo = deviceInfos[i];\r\n\r\n        let info = {};\r\n\r\n        info.deviceId = deviceInfo.deviceId;\r\n\r\n        if (deviceInfo.kind === 'audioinput') {\r\n\r\n            info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\r\n            devices.audioinput.push(info);\r\n        } else if (deviceInfo.kind === 'audiooutput') {\r\n\r\n            info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\r\n            devices.audiooutput.push(info);\r\n        } else if (deviceInfo.kind === 'videoinput') {\r\n\r\n            info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\r\n            devices.videoinput.push(info);\r\n        } else {\r\n\r\n            info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\r\n            devices.other.push(info);\r\n        }\r\n    }\r\n\r\n    return devices;\r\n}\r\n\r\nfunction initConfig(instance, options) {\r\n\r\n    instance.stream = null;\r\n    instance.webSocket = null;\r\n    instance.peerConnection = null;\r\n    instance.connectionConfig = {};\r\n\r\n    instance.status = 'creating';\r\n\r\n    instance.videoElement = null;\r\n    instance.connectionUrl = null;\r\n\r\n    if (options && options.callbacks) {\r\n\r\n        instance.callbacks = options.callbacks;\r\n    } else {\r\n        instance.callbacks = {};\r\n    }\r\n\r\n}\r\n\r\nfunction addMethod(instance) {\r\n\r\n    function errorHandler(error) {\r\n\r\n        if (instance.callbacks.error) {\r\n\r\n            instance.callbacks.error(error);\r\n        }\r\n    }\r\n\r\n    function getUserMedia(constraints) {\r\n\r\n        if (!constraints) {\r\n\r\n            constraints = {\r\n                video: {\r\n                    deviceId: undefined\r\n                },\r\n                audio: {\r\n                    deviceId: undefined\r\n                }\r\n            };\r\n        }\r\n\r\n        console.info(logHeader, 'Requested Constraint To Input Devices', constraints);\r\n\r\n        return navigator.mediaDevices.getUserMedia(constraints)\r\n            .then(function (stream) {\r\n\r\n                console.info(logHeader, 'Received Media Stream From Input Device', stream);\r\n\r\n                instance.stream = stream;\r\n\r\n                let elem = instance.videoElement;\r\n\r\n                // Attach stream to video element when video element is provided.\r\n                if (elem) {\r\n\r\n                    elem.srcObject = stream;\r\n\r\n                    elem.onloadedmetadata = function (e) {\r\n\r\n                        elem.play();\r\n                    };\r\n                }\r\n\r\n                return new Promise(function (resolve) {\r\n\r\n                    resolve(stream);\r\n                });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error(logHeader, 'Can\\'t Get Media Stream From Input Device', error);\r\n                errorHandler(error);\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    reject(error);\r\n                });\r\n            });\r\n    }\r\n\r\n    function getDisplayMedia(constraints) {\r\n\r\n        if (!constraints) {\r\n            constraints = {};\r\n        }\r\n\r\n        console.info(logHeader, 'Requested Constraint To Display', constraints);\r\n\r\n        return navigator.mediaDevices.getDisplayMedia(constraints)\r\n            .then(function (stream) {\r\n\r\n                console.info(logHeader, 'Received Media Stream From Display', stream);\r\n\r\n                instance.stream = stream;\r\n\r\n                let elem = instance.videoElement;\r\n\r\n                // Attach stream to video element when video element is provided.\r\n                if (elem) {\r\n\r\n                    elem.srcObject = stream;\r\n\r\n                    elem.onloadedmetadata = function (e) {\r\n\r\n                        elem.play();\r\n                    };\r\n                }\r\n\r\n                return new Promise(function (resolve) {\r\n\r\n                    resolve(stream);\r\n                });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error(logHeader, 'Can\\'t Get Media Stream From Display', error);\r\n                errorHandler(error);\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    reject(error);\r\n                });\r\n            });\r\n    }\r\n\r\n    // From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\r\n    function setBitrateLimit(sdp, media, bitrate) {\r\n\r\n        let lines = sdp.split('\\n');\r\n        let line = -1;\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (lines[i].indexOf('m=' + media) === 0) {\r\n                line = i;\r\n                break;\r\n            }\r\n        }\r\n        if (line === -1) {\r\n            // Could not find the m line for media\r\n            return sdp;\r\n        }\r\n\r\n        // Pass the m line\r\n        line++;\r\n\r\n        // Skip i and c lines\r\n        while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\r\n\r\n            line++;\r\n        }\r\n\r\n        // If we're on a b line, replace it\r\n        if (lines[line].indexOf('b') === 0) {\r\n\r\n            lines[line] = 'b=AS:' + bitrate;\r\n\r\n            return lines.join('\\n');\r\n        }\r\n\r\n        // Add a new b line\r\n        let newLines = lines.slice(0, line)\r\n\r\n        newLines.push('b=AS:' + bitrate)\r\n        newLines = newLines.concat(lines.slice(line, lines.length))\r\n\r\n        return newLines.join('\\n')\r\n    }\r\n\r\n    function initWebSocket(connectionUrl) {\r\n\r\n        if (!connectionUrl) {\r\n            errorHandler('connectionUrl is required');\r\n            return;\r\n        }\r\n\r\n        instance.connectionUrl = connectionUrl;\r\n\r\n        let webSocket = null;\r\n\r\n        try {\r\n\r\n            webSocket = new WebSocket(connectionUrl);\r\n        } catch (error) {\r\n\r\n            errorHandler(error);\r\n        }\r\n\r\n\r\n        instance.webSocket = webSocket;\r\n\r\n        webSocket.onopen = function () {\r\n\r\n            // Request offer at the first time.\r\n            sendMessage(webSocket, {\r\n                command: 'request_offer'\r\n            });\r\n        };\r\n\r\n        webSocket.onmessage = function (e) {\r\n\r\n            let message = JSON.parse(e.data);\r\n\r\n            if (message.error) {\r\n                console.error('webSocket.onmessage', message.error);\r\n                errorHandler(message.error);\r\n            }\r\n\r\n            if (message.command === 'offer') {\r\n\r\n                pendingRemoteCandidates = [];\r\n                remoteDescriptionSet = false;                \r\n\r\n                // OME returns offer. Start create peer connection.\r\n                createPeerConnection(\r\n                    message.id,\r\n                    message.peer_id,\r\n                    message.sdp,\r\n                    message.candidates,\r\n                    message.ice_servers\r\n                );\r\n            }\r\n\r\n            // // ✅ New: accept remote trickle candidates\r\n            // if (message.command === 'candidate' && instance.peerConnection && message.candidates?.length) {\r\n            //     addIceCandidate(instance.peerConnection, message.candidates);\r\n            //     return;\r\n            // }   \r\n            \r\n            // ✅ Accept remote trickle candidates with a small queue\r\n            if (message.command === 'candidate' && message.candidates?.length) {\r\n                if (!instance.peerConnection || !remoteDescriptionSet) {\r\n                    pendingRemoteCandidates.push(...message.candidates);\r\n                } else {\r\n                    addIceCandidate(instance.peerConnection, message.candidates);\r\n                }\r\n                return;\r\n            }            \r\n        };\r\n\r\n        webSocket.onerror = function (error) {\r\n\r\n            console.error('webSocket.onerror', error);\r\n            errorHandler(error);\r\n        };\r\n\r\n        webSocket.onclose = function (e) {\r\n\r\n            if (!instance.removing) {\r\n\r\n                if (instance.callbacks.connectionClosed) {\r\n\r\n                    instance.callbacks.connectionClosed('websocket', e);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n\r\n    function appendFmtp(sdp) {\r\n\r\n        const fmtpStr = instance.connectionConfig.sdp.appendFmtp;\r\n\r\n        const lines = sdp.split('\\n');\r\n        const payloads = [];\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n\r\n            if (lines[i].indexOf('m=video') === 0) {\r\n\r\n                let tokens = lines[i].split(' ')\r\n\r\n                for (let j = 3; j < tokens.length; j++) {\r\n\r\n                    payloads.push(tokens[j].replace('\\r', ''));\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < payloads.length; i++) {\r\n\r\n            let fmtpLineFound = false;\r\n\r\n            for (let j = 0; j < lines.length; j++) {\r\n\r\n                if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\r\n                    fmtpLineFound = true;\r\n                    lines[j] += ';' + fmtpStr;\r\n                }\r\n            }\r\n\r\n            if (!fmtpLineFound) {\r\n\r\n                for (let j = 0; j < lines.length; j++) {\r\n\r\n                    if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\r\n\r\n                        lines[j] += '\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lines.join('\\n')\r\n    }\r\n\r\n    function createPeerConnection(id, peerId, offer, candidates, iceServers) {\r\n\r\n        window.connectionData = {\r\n            id,\r\n            peerId\r\n        }\r\n\r\n        let peerConnectionConfig = {};\r\n\r\n        if (instance.connectionConfig.iceServers) {\r\n\r\n            // first priority using ice servers from local config.\r\n            peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\r\n\r\n            if (instance.connectionConfig.iceTransportPolicy) {\r\n\r\n                // peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\r\n\r\n                // Instead of always forcing relay:\r\n                peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy || 'all';\r\n\r\n            }\r\n        } else if (iceServers) {\r\n\r\n            // second priority using ice servers from ome and force using TCP\r\n            peerConnectionConfig.iceServers = [];\r\n\r\n            for (let i = 0; i < iceServers.length; i++) {\r\n\r\n                let iceServer = iceServers[i];\r\n\r\n                let regIceServer = {};\r\n\r\n                regIceServer.urls = iceServer.urls;\r\n\r\n                let hasWebSocketUrl = false;\r\n                let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\r\n\r\n                for (let j = 0; j < regIceServer.urls.length; j++) {\r\n\r\n                    let serverUrl = regIceServer.urls[j];\r\n\r\n                    if (serverUrl.indexOf(webSocketUrl) > -1) {\r\n                        hasWebSocketUrl = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!hasWebSocketUrl) {\r\n\r\n                    if (regIceServer.urls.length > 0) {\r\n\r\n                        let cloneIceServer = regIceServer.urls[0];\r\n                        let ip = findIp(cloneIceServer);\r\n\r\n                        if (webSocketUrl && ip) {\r\n                            regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                regIceServer.username = iceServer.user_name;\r\n                regIceServer.credential = iceServer.credential;\r\n\r\n                peerConnectionConfig.iceServers.push(regIceServer);\r\n            }\r\n\r\n            peerConnectionConfig.iceTransportPolicy = 'relay';\r\n        } else {\r\n            // last priority using default ice servers.\r\n\r\n            if (instance.iceTransportPolicy) {\r\n\r\n                peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\r\n            }\r\n        }\r\n\r\n        let advancedSetting = {\r\n            optional: [\r\n                {\r\n                    googHighStartBitrate: {\r\n                        exact: !0\r\n                    }\r\n                },\r\n                {\r\n                    googPayloadPadding: {\r\n                        exact: !0\r\n                    }\r\n                },\r\n                {\r\n                    googScreencastMinBitrate: {\r\n                        exact: 500\r\n                    }\r\n                },\r\n                {\r\n                    enableDscp: {\r\n                        exact: true\r\n                    }\r\n                }\r\n            ]\r\n        };\r\n\r\n        console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\r\n\r\n        let peerConnection = new RTCPeerConnection(peerConnectionConfig);\r\n\r\n        instance.peerConnection = peerConnection;\r\n\r\n        // set local stream\r\n        instance.stream.getTracks().forEach(function (track) {\r\n\r\n            console.info(logHeader, 'Add Track To Peer Connection', track);\r\n            peerConnection.addTrack(track, instance.stream);\r\n        });\r\n\r\n\r\n        // if (checkIOSVersion() >= 15) {\r\n        //     const formatNumber = getFormatNumber(offer.sdp, 'H264');\r\n\r\n        //     if (formatNumber > 0) {\r\n        //         offer.sdp = removeFormat(offer.sdp, formatNumber);\r\n        //     }\r\n        // }\r\n\r\n        if (instance.connectionConfig.maxVideoBitrate) {\r\n\r\n            // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\r\n            offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\r\n        }\r\n\r\n        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\r\n\r\n            offer.sdp = appendFmtp(offer.sdp);\r\n        }\r\n\r\n        peerConnection.setRemoteDescription(new RTCSessionDescription(offer))\r\n            .then(function () {\r\n\r\n                remoteDescriptionSet = true;\r\n                if (pendingRemoteCandidates.length) {\r\n                    addIceCandidate(instance.peerConnection || peerConnection, pendingRemoteCandidates);\r\n                    pendingRemoteCandidates = [];\r\n                }\r\n\r\n                peerConnection.createAnswer()\r\n                    .then(function (answer) {\r\n\r\n                        // if (checkIOSVersion() >= 15) {\r\n\r\n                        //     const formatNumber = getFormatNumber(answer.sdp, 'H264');\r\n\r\n                        //     if (formatNumber > 0) {\r\n\r\n                        //         answer.sdp = removeFormat(answer.sdp, formatNumber);\r\n                        //     }\r\n                        // }\r\n\r\n                        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\r\n\r\n                            answer.sdp = appendFmtp(answer.sdp);\r\n                        }\r\n\r\n                        peerConnection.setLocalDescription(answer)\r\n                            .then(function () {\r\n\r\n                                sendMessage(instance.webSocket, {\r\n                                    id: id,\r\n                                    peer_id: peerId,\r\n                                    command: 'answer',\r\n                                    sdp: answer\r\n                                });\r\n                            })\r\n                            .catch(function (error) {\r\n\r\n                                console.error('peerConnection.setLocalDescription', error);\r\n                                errorHandler(error);\r\n                            });\r\n                    })\r\n                    .catch(function (error) {\r\n\r\n                        console.error('peerConnection.createAnswer', error);\r\n                        errorHandler(error);\r\n                    });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error('peerConnection.setRemoteDescription', error);\r\n                errorHandler(error);\r\n            });\r\n\r\n        if (candidates) {\r\n\r\n            addIceCandidate(peerConnection, candidates);\r\n        }\r\n\r\n        peerConnection.onicecandidate = function (e) {\r\n\r\n            if (e.candidate && e.candidate.candidate) {\r\n\r\n                console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\r\n\r\n                sendMessage(instance.webSocket, {\r\n                    id: id,\r\n                    peer_id: peerId,\r\n                    command: 'candidate',\r\n                    candidates: [e.candidate]\r\n                });\r\n            }\r\n        };\r\n\r\n        peerConnection.oniceconnectionstatechange = function (e) {\r\n\r\n            let state = peerConnection.iceConnectionState;\r\n\r\n            if (instance.callbacks.iceStateChange) {\r\n\r\n                console.info(logHeader, 'ICE State', '[' + state + ']');\r\n                instance.callbacks.iceStateChange(state);\r\n            }\r\n\r\n            if (state === 'connected') {\r\n\r\n                if (instance.callbacks.connected) {\r\n\r\n                    console.info(logHeader, 'Iceconnection Connected', e);\r\n                    instance.callbacks.connected(e);\r\n                }\r\n            }\r\n\r\n            if (state === 'failed' || state === 'disconnected' || state === 'closed') {\r\n\r\n                if (instance.callbacks.connectionClosed) {\r\n\r\n                    console.error(logHeader, 'Iceconnection Closed', e);\r\n                    instance.callbacks.connectionClosed('ice', e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIceCandidate(peerConnection, candidates) {\r\n\r\n        for (let i = 0; i < candidates.length; i++) {\r\n\r\n            if (candidates[i] && candidates[i].candidate) {\r\n\r\n                let basicCandidate = candidates[i];\r\n\r\n                peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate))\r\n                    .then(function () {\r\n\r\n                    })\r\n                    .catch(function (error) {\r\n\r\n                        console.error('peerConnection.addIceCandidate', error);\r\n                        errorHandler(error);\r\n                    });\r\n            }\r\n        }\r\n    }\r\n\r\n    // instance methods\r\n    instance.attachMedia = function (videoElement) {\r\n\r\n        instance.videoElement = videoElement;\r\n    };\r\n\r\n    instance.getUserMedia = function (constraints) {\r\n\r\n        return getUserMedia(constraints);\r\n    };\r\n\r\n    instance.getDisplayMedia = function (constraints) {\r\n\r\n        return getDisplayMedia(constraints);\r\n    };\r\n\r\n    instance.startStreaming = function (connectionUrl, connectionConfig) {\r\n\r\n        connectionUrl+=\"?direction=send&transport=tcp\"\r\n\r\n        console.info(logEventHeader, 'Start Streaming');\r\n\r\n        if (connectionConfig) {\r\n\r\n            instance.connectionConfig = connectionConfig;\r\n        }\r\n\r\n        initWebSocket(connectionUrl);\r\n    };\r\n\r\n    instance.remove = function () {\r\n\r\n        instance.removing = true;\r\n\r\n        // first release peer connection with ome\r\n        if (instance.peerConnection) {\r\n\r\n            // remove tracks from peer connection\r\n            instance.peerConnection.getSenders().forEach(function (sender) {\r\n                instance.peerConnection.removeTrack(sender);\r\n            });\r\n\r\n            instance.peerConnection.close();\r\n            instance.peerConnection = null;\r\n            delete instance.peerConnection;\r\n        }\r\n\r\n        // release video, audio stream\r\n        if (instance.stream) {\r\n\r\n            instance.stream.getTracks().forEach(track => {\r\n\r\n                track.stop();\r\n                instance.stream.removeTrack(track);\r\n            });\r\n\r\n            if (instance.videoElement) {\r\n                instance.videoElement.srcObject = null;\r\n            }\r\n\r\n            instance.stream = null;\r\n            delete instance.stream;\r\n        }\r\n\r\n        // release websocket\r\n        if (instance.webSocket) {\r\n            \r\n            sendMessage(instance.webSocket, {\r\n                id: window.connectionData.id,\r\n                peer_id: window.connectionData.peerId,\r\n                command: 'stop',\r\n            });\r\n\r\n            instance.webSocket.close();\r\n            instance.webSocket = null;\r\n            delete instance.webSocket;\r\n        }\r\n\r\n        instance.status = 'removed';\r\n\r\n        console.info(logEventHeader, 'Removed');\r\n\r\n    };\r\n}\r\n\r\n// static methods\r\nQencodeWebRTC.create = function (options) {\r\n\r\n    console.info(logEventHeader, 'Create WebRTC');\r\n\r\n    let instance = {};\r\n\r\n    instance.removing = false;\r\n\r\n    initConfig(instance, options);\r\n    addMethod(instance);\r\n\r\n    return instance;\r\n};\r\n\r\nQencodeWebRTC.getDevices = async function () {\r\n\r\n    await getStreamForDeviceCheck();\r\n    const deviceInfos = await getDevices();\r\n    return gotDevices(deviceInfos)\r\n};\r\n\r\nexport default QencodeWebRTC;"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","pendingRemoteCandidates","remoteDescriptionSet","sendMessage","webSocket","message","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","addMethod","instance","errorHandler","error","callbacks","appendFmtp","sdp","fmtpStr","connectionConfig","lines","split","payloads","i","length","indexOf","tokens","j","push","replace","fmtpLineFound","join","addIceCandidate","peerConnection","candidates","candidate","basicCandidate","RTCIceCandidate","then","catch","console","attachMedia","videoElement","getUserMedia","constraints","video","deviceId","undefined","audio","info","navigator","mediaDevices","stream","elem","srcObject","onloadedmetadata","e","play","Promise","resolve","reject","getDisplayMedia","startStreaming","connectionUrl","WebSocket","onopen","command","onmessage","parse","data","id","peerId","offer","iceServers","window","connectionData","peerConnectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","getTracks","forEach","track","addTrack","maxVideoBitrate","media","bitrate","line","newLines","slice","concat","setBitrateLimit","setRemoteDescription","RTCSessionDescription","createAnswer","answer","setLocalDescription","peer_id","onicecandidate","oniceconnectionstatechange","state","iceConnectionState","iceStateChange","connected","connectionClosed","createPeerConnection","ice_servers","onerror","onclose","removing","initWebSocket","remove","getSenders","sender","removeTrack","close","stop","status","create","options","initConfig","getDevices","async","width","height","getStreamForDeviceCheck","deviceInfos","devices","deviceInfo","kind","label","audioinput","audiooutput","videoinput","other","gotDevices","enumerateDevices"],"sourceRoot":""}