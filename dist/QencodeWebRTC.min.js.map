{"version":3,"file":"QencodeWebRTC.min.js","mappings":"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","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","interface QencodeWebRTCStatic {\n  create(config?: CreateConfig): QencodeWebRtcInstance;\n  getDevices(): Promise<Devices>;\n}\n\nconst QencodeWebRTC: QencodeWebRTCStatic = {} as QencodeWebRTCStatic;\n\nconst logHeader = 'QencodeWebRTC.js :';\nconst logEventHeader = 'QencodeWebRTC.js :';\n\ntype WebSocketMessage =\n  | {\n      command: 'request_offer';\n    }\n  | {\n      id: string;\n      peer_id: string | number; // todo clarify\n      command: 'candidate';\n      candidates: RTCIceCandidate[];\n    }\n  | {\n      id: string;\n      peer_id: string | number; // todo clarify\n      command: 'answer';\n      sdp: RTCSessionDescriptionInit;\n    }\n  | {\n      id: string;\n      peer_id: string | number; // todo clarify\n      command: 'stop';\n    };\n\n// private methods\nfunction sendMessage(webSocket: WebSocket, message: WebSocketMessage) {\n  if (webSocket && webSocket.readyState === WebSocket.OPEN) {\n    webSocket.send(JSON.stringify(message));\n  }\n}\n\nfunction generateDomainFromUrl(url: string) {\n  let result = '';\n  let match;\n  if ((match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im))) {\n    result = match[1];\n  }\n\n  return result;\n}\n\nfunction findIp(string: string) {\n  let result = '';\n  let match;\n\n  if (\n    (match = string.match(\n      new RegExp(\n        '\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b',\n        'gi'\n      )\n    ))\n  ) {\n    result = match[0];\n  }\n\n  return result;\n}\n\nfunction checkIOSVersion() {\n  var agent = window.navigator.userAgent,\n    start = agent.indexOf('OS ');\n  if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\n    return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\n  }\n  return 0;\n}\n\n// SDP helper functions to properly handle CRLF line endings (RFC 4566)\nfunction splitSdpLines(sdp: string) {\n  // Normalize line endings: split on \\r\\n or \\n, and remove trailing \\r from each line\n  return sdp.split(/\\r?\\n/).map((line) => line.replace(/\\r$/, ''));\n}\n\nfunction joinSdpLines(lines: string[]) {\n  // Join with CRLF as required by SDP specification (RFC 4566)\n  return lines.join('\\r\\n');\n}\n\nfunction getFormatNumber(sdp, format) {\n  const lines = splitSdpLines(sdp);\n  let formatNumber = -1;\n\n  for (let i = 0; i < lines.length - 1; i++) {\n    lines[i] = lines[i].toLowerCase();\n\n    if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\n      // parsing \"a=rtpmap:100 H264/90000\" line\n      formatNumber = lines[i].split(' ')[0].split(':')[1];\n      break;\n    }\n  }\n\n  return formatNumber;\n}\n\nfunction removeFormat(sdp, formatNumber) {\n  let newLines = [];\n  let lines = splitSdpLines(sdp);\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=video') === 0) {\n      newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\n    } else if (lines[i].indexOf(formatNumber + '') > -1) {\n    } else {\n      newLines.push(lines[i]);\n    }\n  }\n\n  return joinSdpLines(newLines);\n}\n\nasync function getStreamForDeviceCheck() {\n  // High resolution video constraints makes browser to get maximum resolution of video device.\n  // Using 'ideal' instead of exact values for better compatibility with different cameras.\n  const constraints = {\n    audio: { deviceId: undefined },\n    video: { deviceId: undefined, width: { ideal: 1920 }, height: { ideal: 1080 } },\n  };\n\n  return await navigator.mediaDevices.getUserMedia(constraints);\n}\n\nasync function getDevices() {\n  return await navigator.mediaDevices.enumerateDevices();\n}\n\nfunction gotDevices(deviceInfos: MediaDeviceInfo[]): Devices {\n  let devices = {\n    audioinput: [],\n    audiooutput: [],\n    videoinput: [],\n    other: [],\n  };\n\n  for (let i = 0; i !== deviceInfos.length; ++i) {\n    const deviceInfo = deviceInfos[i];\n\n    let info = {};\n\n    info.deviceId = deviceInfo.deviceId;\n\n    if (deviceInfo.kind === 'audioinput') {\n      info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\n      devices.audioinput.push(info);\n    } else if (deviceInfo.kind === 'audiooutput') {\n      info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\n      devices.audiooutput.push(info);\n    } else if (deviceInfo.kind === 'videoinput') {\n      info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\n      devices.videoinput.push(info);\n    } else {\n      info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\n      devices.other.push(info);\n    }\n  }\n\n  return devices;\n}\n\ninterface Candidate {\n  sdpMLineIndex: number;\n  candidate: string;\n}\n\ninterface IceServer {\n  credential: string;\n  urls: string[];\n  user_name: string;\n}\n\ninterface Offer {\n  sdp: string;\n  type: 'offer';\n}\n\ninterface ConnectionConfig {\n  iceServers?: RTCIceServer[];\n  iceTransportPolicy?: RTCIceTransportPolicy;\n  maxVideoBitrate?: number;\n  sdp?: {\n    appendFmtp?: string;\n  };\n}\n\ninterface ConnectionData {\n  id: string;\n  peerId: string | number;\n}\n\ninterface Callbacks {\n  error?: (error: any) => void;\n  connected?: (event: Event) => void;\n  connectionClosed?: (source: 'websocket' | 'ice', event: Event | CloseEvent) => void;\n  iceStateChange?: (state: RTCIceConnectionState) => void;\n}\n\ninterface CreateConfig {\n  callbacks?: Callbacks;\n}\n\ninterface DeviceInfo {\n  deviceId: string;\n  label: string;\n}\n\ninterface Devices {\n  audioinput: DeviceInfo[];\n  audiooutput: DeviceInfo[];\n  videoinput: DeviceInfo[];\n  other: DeviceInfo[];\n}\n\ninterface QencodeWebRtcInstance {\n  // Configuration properties\n  retryMaxCount: number;\n  retryDelay: number;\n  connectionConfig: ConnectionConfig;\n  connectionUrl: string | null;\n  iceTransportPolicy?: RTCIceTransportPolicy;\n\n  // State properties\n  connectStarted: boolean;\n  error: any;\n  offerRequestCount: number;\n  retriesUsed: number;\n  isManualStop: boolean;\n\n  // Connection properties\n  peerConnection: RTCPeerConnection | null;\n  webSocket: WebSocket | null;\n  webSocketCloseEvent: CloseEvent | null;\n  connectionData?: ConnectionData;\n\n  // Media properties\n  stream: MediaStream | null;\n  videoElement: HTMLVideoElement | null;\n\n  // Internal state\n  iceDisconnectTimeoutId?: NodeJS.Timeout | null;\n  reconnectWebSocketPromise?: Promise<void> | null;\n  iceLastEvent?: Event;\n  callbacks: Callbacks;\n\n  // Methods\n  attachMedia(videoElement: HTMLVideoElement): void;\n  getUserMedia(constraints?: MediaStreamConstraints): Promise<MediaStream>;\n  getDisplayMedia(constraints?: DisplayMediaStreamConstraints): Promise<MediaStream>;\n  switchCamera(\n    deviceId: string,\n    extraVideoConstraints?: MediaTrackConstraints\n  ): Promise<MediaStream>;\n  hasActiveConnection(): boolean;\n  startStreaming(connectionUrl: string, connectionConfig?: ConnectionConfig): void;\n  closePeerConnection(): void;\n  closeWebSocket(): void;\n  closeVideoAudioStreams(): void;\n  remove(): void;\n}\n\nfunction initConfig(config?: CreateConfig) {\n  let instance: QencodeWebRtcInstance = {\n    retryMaxCount: 2,\n    retryDelay: 2000,\n    connectionConfig: {},\n    connectionUrl: null,\n    connectStarted: false,\n    error: null,\n    offerRequestCount: 0,\n    peerConnection: null,\n    retriesUsed: 0,\n    stream: null,\n    videoElement: null,\n    webSocket: null,\n    webSocketCloseEvent: null,\n    isManualStop: false,\n  };\n\n  if (config && config.callbacks) {\n    instance.callbacks = config.callbacks;\n  } else {\n    instance.callbacks = {};\n  }\n\n  return instance;\n}\n\nfunction waitForOnline() {\n  if (navigator.onLine) {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve) => {\n    console.log('Offline. Waiting for connection...');\n    // Use { once: true } to auto-remove the listener after it fires\n    window.addEventListener(\n      'online',\n      () => {\n        console.log('Back online!');\n        resolve();\n      },\n      { once: true }\n    );\n  });\n}\n\nfunction delayedCall(fn, args, delay) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      Promise.resolve(fn(...args)).then(resolve);\n    }, delay);\n  });\n}\n\n// From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\nfunction setBitrateLimit(sdp, media, bitrate) {\n  let lines = splitSdpLines(sdp);\n  let line = -1;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=' + media) === 0) {\n      line = i;\n      break;\n    }\n  }\n  if (line === -1) {\n    // Could not find the m line for media\n    return sdp;\n  }\n\n  // Pass the m line\n  line++;\n\n  // Skip i and c lines\n  while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\n    line++;\n  }\n\n  // If we're on a b line, replace it\n  if (lines[line].indexOf('b') === 0) {\n    lines[line] = 'b=AS:' + bitrate;\n\n    return joinSdpLines(lines);\n  }\n\n  // Add a new b line\n  let newLines = lines.slice(0, line);\n\n  newLines.push('b=AS:' + bitrate);\n  newLines = newLines.concat(lines.slice(line, lines.length));\n\n  return joinSdpLines(newLines);\n}\n\nfunction appendFmtp(fmtpStr, sdp) {\n  const lines = splitSdpLines(sdp);\n  const payloads = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=video') === 0) {\n      let tokens = lines[i].split(' ');\n\n      for (let j = 3; j < tokens.length; j++) {\n        payloads.push(tokens[j]);\n      }\n\n      break;\n    }\n  }\n\n  for (let i = 0; i < payloads.length; i++) {\n    let fmtpLineFound = false;\n\n    for (let j = 0; j < lines.length; j++) {\n      if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\n        fmtpLineFound = true;\n        lines[j] += ';' + fmtpStr;\n      }\n    }\n\n    if (!fmtpLineFound) {\n      for (let j = 0; j < lines.length; j++) {\n        if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\n          lines[j] += '\\r\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\n        }\n      }\n    }\n  }\n\n  return joinSdpLines(lines);\n}\n\nfunction addMethod(instance: QencodeWebRtcInstance) {\n  function errorHandler(error) {\n    instance.error = error;\n    if (typeof instance.callbacks?.error === 'function') {\n      try {\n        instance.callbacks.error(error);\n      } catch (callbackError) {\n        console.error(logHeader, 'Error in error callback', callbackError);\n      }\n    }\n  }\n  async function replaceTracksInPeerConnection(newStream: MediaStream) {\n    if (!instance.peerConnection || !newStream) {\n      return {\n        replacedVideo: false,\n        replacedAudio: false,\n        oldVideoTrack: null,\n        oldAudioTrack: null,\n        newVideoTrack: null,\n        newAudioTrack: null,\n      };\n    }\n\n    const pc = instance.peerConnection;\n    const newVideoTrack = newStream.getVideoTracks()[0] || null;\n    const newAudioTrack = newStream.getAudioTracks()[0] || null;\n\n    const senders = pc.getSenders();\n    const videoSender = senders.find((s) => s.track && s.track.kind === 'video') || null;\n    const audioSender = senders.find((s) => s.track && s.track.kind === 'audio') || null;\n\n    const oldVideoTrack = videoSender?.track || null;\n    const oldAudioTrack = audioSender?.track || null;\n\n    let replacedVideo = false;\n    let replacedAudio = false;\n\n    // replaceTracksInPeerConnection gracefully handles the missing audio track in the new stream by skipping the audio replacement logic. This ensures that the microphone input is never interrupted, which is a common pain point in WebRTC implementations.\n    if (newVideoTrack && videoSender) {\n      try {\n        await videoSender.replaceTrack(newVideoTrack);\n        replacedVideo = true;\n        console.info(logHeader, 'Replaced video track in peer connection');\n      } catch (error) {\n        console.error(logHeader, 'Error replacing video track', error);\n        errorHandler(error);\n      }\n    } else if (newVideoTrack && !videoSender) {\n      // sender.replaceTrack only works if a sender for that media type already exists.\n      console.warn(logHeader, 'No video sender found; cannot replaceTrack without renegotiation.');\n    }\n\n    if (newAudioTrack && audioSender) {\n      try {\n        await audioSender.replaceTrack(newAudioTrack);\n        replacedAudio = true;\n        console.info(logHeader, 'Replaced audio track in peer connection');\n      } catch (error) {\n        console.error(logHeader, 'Error replacing audio track', error);\n        errorHandler(error);\n      }\n    } else if (newAudioTrack && !audioSender) {\n      console.warn(logHeader, 'No audio sender found; cannot replaceTrack without renegotiation.');\n    }\n\n    return {\n      replacedVideo,\n      replacedAudio,\n      oldVideoTrack,\n      oldAudioTrack,\n      newVideoTrack,\n      newAudioTrack,\n    };\n  }\n  function getUserMedia(constraints): Promise<MediaStream> {\n    if (!constraints) {\n      constraints = {\n        video: {\n          deviceId: undefined,\n        },\n        audio: {\n          deviceId: undefined,\n        },\n      };\n    }\n\n    return navigator.mediaDevices\n      .getUserMedia(constraints)\n      .then(async function (stream) {\n        console.info(logHeader, 'Received Media Stream From Input Device', stream);\n\n        return await replaceStream(stream);\n      })\n      .catch(function (error) {\n        console.error(logHeader, \"Can't Get Media Stream From Input Device\", error);\n        errorHandler(error);\n        throw error;\n      });\n  }\n\n  async function replaceStream(stream: MediaStream) {\n    const hasActiveConnection = instance.hasActiveConnection();\n    const oldStream = instance.stream;\n\n    if (hasActiveConnection && oldStream) {\n      const rep = await replaceTracksInPeerConnection(stream);\n\n      if (rep.replacedVideo) {\n        oldStream.getVideoTracks().forEach((t) => t.stop());\n      }\n      if (rep.replacedAudio) {\n        oldStream.getAudioTracks().forEach((t) => t.stop());\n      }\n\n      // Compose: screen video + keep existing mic if screen share has no audio\n      const composed = new MediaStream();\n\n      if (rep.newVideoTrack) {\n        composed.addTrack(rep.newVideoTrack);\n      } else if (oldStream.getVideoTracks()[0]) {\n        composed.addTrack(oldStream.getVideoTracks()[0]);\n      }\n\n      if (rep.newAudioTrack) {\n        composed.addTrack(rep.newAudioTrack);\n      } else if (oldStream.getAudioTracks()[0]) {\n        composed.addTrack(oldStream.getAudioTracks()[0]);\n      }\n\n      instance.stream = composed;\n\n      const elem = instance.videoElement;\n      if (elem) {\n        elem.srcObject = composed;\n        elem.onloadedmetadata = function (e) {\n          elem.play();\n        };\n      }\n\n      return composed;\n    }\n\n    instance.stream = stream;\n    const elem = instance.videoElement;\n\n    if (elem) {\n      elem.srcObject = stream;\n      elem.onloadedmetadata = function (e) {\n        elem.play();\n      };\n    }\n\n    return stream;\n  }\n\n  function getDisplayMedia(constraints) {\n    if (!constraints) {\n      constraints = {};\n    }\n\n    return navigator.mediaDevices\n      .getDisplayMedia(constraints)\n      .then(async function (stream) {\n        console.info(logHeader, 'Received Media Stream From Display', stream);\n        return await replaceStream(stream);\n      })\n      .catch(function (error) {\n        console.error(logHeader, \"Can't Get Media Stream From Display\", error);\n        errorHandler(error);\n        throw error;\n      });\n  }\n\n  // Switch only the camera (video sender) without touching microphone / audio sender.\n  // It handles initial setup by requesting audio if no existing audio track is found.\n  async function switchCamera(deviceId: string) {\n    // [FIX] Define default constraints to enforce 16:9 (HD) aspect ratio.\n    const defaultConstraints = {\n      width: { ideal: 1920 },\n      height: { ideal: 1080 },\n      // Explicitly specify aspect ratio if width/height aren't enough. Looks important in practice.\n      aspectRatio: { ideal: 1.7777777778 },\n    };\n\n    const finalVideoConstraints = {\n      ...defaultConstraints,\n      ...(deviceId ? { deviceId: { exact: deviceId } } : {}),\n    };\n    console.log('finalVideoConstraints', finalVideoConstraints);\n\n    // 1. Move oldStream retrieval UP to check for existing audio\n    const oldStream = instance.stream;\n    const oldAudioTrack = oldStream?.getAudioTracks?.()[0] ?? null;\n\n    // 2. Determine if we need to request audio (Initial Setup vs Camera Switch)\n    const shouldRequestAudio = !oldAudioTrack;\n\n    // 3. Update constraints to request audio only if we don't have it\n    const constraints = {\n      video: finalVideoConstraints,\n      audio: shouldRequestAudio,\n    };\n\n    let newCamStream: MediaStream;\n    try {\n      instance.getUserMediaError = null;\n      newCamStream = await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (e) {\n      instance.getUserMediaError = e;\n      // Fallback: relax constraints (prevents “camera switch randomly fails”)\n      const fallback = {\n        video: deviceId ? { deviceId: { exact: deviceId } } : true,\n        audio: shouldRequestAudio, // Apply audio logic to fallback too\n      };\n      newCamStream = await navigator.mediaDevices.getUserMedia(fallback as any);\n    }\n\n    const hasActiveConnection = instance.hasActiveConnection();\n\n    if (!hasActiveConnection || !oldStream) {\n      // Stop ONLY the old camera tracks to release hardware\n      if (oldStream) {\n        oldStream.getVideoTracks().forEach((track) => track.stop());\n      }\n\n      // Build a composed stream\n      const composed = new MediaStream();\n\n      const newVideoTrack = newCamStream.getVideoTracks()[0];\n      if (newVideoTrack) {\n        composed.addTrack(newVideoTrack);\n      }\n\n      // 4. Logic to add the correct audio track\n      if (shouldRequestAudio) {\n        // Case A: Initial Setup - Use the NEW audio track we just requested\n        const newAudioTrack = newCamStream.getAudioTracks()[0];\n        if (newAudioTrack) {\n          composed.addTrack(newAudioTrack);\n        }\n      } else if (oldAudioTrack) {\n        // Case B: Switching - Keep the OLD audio track (seamless switch)\n        composed.addTrack(oldAudioTrack);\n\n        // Important: If we requested audio: false, newCamStream has no audio tracks,\n        // so we don't need to stop anything there.\n      }\n\n      instance.stream = composed;\n\n      if (instance.videoElement) {\n        instance.videoElement.srcObject = composed;\n      }\n\n      return composed;\n    }\n\n    try {\n      const rep = await replaceTracksInPeerConnection(newCamStream);\n\n      if (rep.replacedVideo) {\n        oldStream.getVideoTracks().forEach((t) => t.stop());\n      } else {\n        newCamStream.getTracks().forEach((t) => t.stop());\n        return oldStream;\n      }\n\n      const composed = new MediaStream();\n\n      if (rep.newVideoTrack) {\n        composed.addTrack(rep.newVideoTrack);\n      } else if (oldStream.getVideoTracks()[0]) {\n        composed.addTrack(oldStream.getVideoTracks()[0]);\n      }\n\n      // We continue to use the existing audio for the local stream object\n      // Note: If we added audio in 'shouldRequestAudio' mode while connected,\n      // it won't be sent to the peer without renegotiation (replaceTrack fails for missing senders).\n      // But this path is rarely hit for \"Initial Setup\" since !hasActiveConnection is usually true then.\n      const existingAudio = oldStream.getAudioTracks()[0];\n      if (existingAudio) {\n        composed.addTrack(existingAudio);\n      }\n\n      instance.stream = composed;\n\n      const elem = instance.videoElement;\n      if (elem) {\n        elem.srcObject = composed;\n        elem.onloadedmetadata = function (e) {\n          elem.play();\n        };\n      }\n\n      return composed;\n    } catch (error) {\n      console.error(logHeader, 'Failed to switch camera', error);\n      if (newCamStream) {\n        newCamStream.getTracks().forEach((track) => track.stop());\n      }\n\n      throw error;\n    }\n  }\n\n  function requestOffer() {\n    sendMessage(instance.webSocket, {\n      command: 'request_offer',\n    });\n    instance.offerRequestCount += 1;\n  }\n\n  async function addRetryToQueue(delay?: number) {\n    if (instance.isManualStop) return;\n\n    if (instance.reconnectWebSocketPromise) {\n      // Just hitch a ride on the existing attempt and exit.\n      await instance.reconnectWebSocketPromise;\n      return;\n    }\n\n    const retryDelay = delay ?? instance.retryDelay;\n\n    instance.reconnectWebSocketPromise = (async () => {\n      try {\n        await delayedCall(reconnectWebSocket, [], retryDelay);\n      } finally {\n        instance.reconnectWebSocketPromise = null;\n      }\n    })();\n\n    await instance.reconnectWebSocketPromise;\n  }\n\n  async function reconnectWebSocket() {\n    await waitForOnline();\n    instance.connectStarted = true;\n\n    // [FIX] Abort if user stopped stream while we were waiting for internet\n    if (instance.isManualStop) return;\n\n    const promise = new Promise(async function (resolve) {\n      let disconnected = true;\n      if (instance.peerConnection) {\n        if (\n          !['failed', 'disconnected', 'closed'].includes(instance.peerConnection.iceConnectionState)\n        ) {\n          disconnected = false;\n        }\n      }\n      if (\n        Number.isFinite(instance.retryDelay) &&\n        Number.isFinite(instance.retryMaxCount) &&\n        instance.retriesUsed < instance.retryMaxCount &&\n        disconnected\n      ) {\n        instance.isManualStop = false;\n        instance.retriesUsed += 1;\n        console.info(`online=${navigator.onLine}. Starting retry attempt ${instance.retriesUsed}`);\n\n        instance.closePeerConnection();\n        instance.closeWebSocket();\n\n        instance.error = null;\n        instance.webSocketCloseEvent = null;\n\n        try {\n          await delayedCall(initWebSocket, [], instance.retryDelay);\n        } catch (e) {\n        } finally {\n          instance.connectStarted = false;\n          resolve();\n        }\n      }\n      resolve();\n    });\n\n    return promise;\n  }\n\n  function initWebSocket() {\n    if (!instance.connectionUrl) {\n      errorHandler('connectionUrl is required');\n      return;\n    }\n\n    let webSocket = null;\n    try {\n      webSocket = new WebSocket(instance.connectionUrl);\n    } catch (error) {\n      errorHandler(error);\n      return;\n    }\n\n    instance.webSocket = webSocket;\n\n    webSocket.onopen = function () {\n      instance.retriesUsed = 0;\n      instance.offerRequestCount = 0;\n      requestOffer();\n    };\n\n    webSocket.onmessage = async function (e) {\n      let message = JSON.parse(e.data);\n\n      if (message.error) {\n        console.error('webSocket.onmessage', message.error);\n        await addRetryToQueue();\n        return;\n      }\n\n      if (message.command === 'offer') {\n        // OME returns offer. Start create peer connection.\n        try {\n          await createPeerConnection(\n            message.id,\n            message.peer_id,\n            message.sdp,\n            message.candidates,\n            message.ice_servers\n          );\n\n          instance.offerRequestCount = 0;\n          instance.connectStarted = false;\n        } catch (e) {\n          instance.connectStarted = false;\n          console.log('createPeerConnection error', e);\n\n          if (instance.offerRequestCount < 3) {\n            requestOffer();\n          } else {\n            await addRetryToQueue();\n          }\n        }\n      }\n    };\n\n    /* For reliability it is recommended to check for error with event code in onclose instead. */\n    webSocket.onerror = (e) => console.log('webSocket.onerror', e);\n\n    webSocket.onclose = async function (event) {\n      console.log('Connection closed', event);\n      instance.webSocketCloseEvent = event;\n      // Check if the close was clean (1000) or caused by an issue\n      if (event.code !== 1000) {\n        await addRetryToQueue();\n      } else {\n        console.log('Connection closed normally.');\n      }\n      instance.connectStarted = false;\n      if (!instance.isManualStop && instance.callbacks.connectionClosed) {\n        try {\n          instance.callbacks.connectionClosed('websocket', event);\n        } catch (callbackError) {\n          console.error(logHeader, 'Error in connectionClosed callback', callbackError);\n        }\n      }\n    };\n  }\n\n  function initRetryAfterLongEnoughIceDisconnect(timeout = 3000) {\n    if (!instance.iceDisconnectTimeoutId) {\n      instance.iceDisconnectTimeoutId = setTimeout(function () {\n        if (instance.isManualStop) return;\n\n        if (\n          instance.peerConnection &&\n          ['failed', 'disconnected'].includes(instance.peerConnection.iceConnectionState)\n        ) {\n          addRetryToQueue(0);\n        }\n      }, timeout);\n    }\n  }\n\n  function cancelRetryAfterLongEnoughIceDisconnect() {\n    clearTimeout(instance.iceDisconnectTimeoutId);\n    instance.iceDisconnectTimeoutId = null;\n  }\n\n  async function createPeerConnection(\n    id: number,\n    peerId: number,\n    offer: Offer,\n    candidates: Candidate[],\n    iceServers: IceServer[]\n  ) {\n    console.log({\n      id,\n      peerId,\n      offer,\n      candidates,\n      iceServers,\n    });\n    instance.connectionData = {\n      id,\n      peerId,\n    };\n\n    let peerConnectionConfig: RTCConfiguration = {};\n\n    if (instance.connectionConfig.iceServers) {\n      // first priority using ice servers from local config.\n      peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\n\n      if (instance.connectionConfig.iceTransportPolicy) {\n        peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\n      }\n    } else if (iceServers) {\n      // second priority using ice servers from ome and force using TCP\n      peerConnectionConfig.iceServers = [];\n\n      for (let i = 0; i < iceServers.length; i++) {\n        let iceServer = iceServers[i];\n        let regIceServer = {};\n        regIceServer.urls = iceServer.urls;\n        let hasWebSocketUrl = false;\n        let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\n\n        for (let j = 0; j < regIceServer.urls.length; j++) {\n          let serverUrl = regIceServer.urls[j];\n\n          if (serverUrl.indexOf(webSocketUrl) > -1) {\n            hasWebSocketUrl = true;\n            break;\n          }\n        }\n\n        if (!hasWebSocketUrl) {\n          if (regIceServer.urls.length > 0) {\n            let cloneIceServer = regIceServer.urls[0];\n            let ip = findIp(cloneIceServer);\n\n            if (webSocketUrl && ip) {\n              regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\n            }\n          }\n        }\n\n        regIceServer.username = iceServer.user_name;\n        regIceServer.credential = iceServer.credential;\n        peerConnectionConfig.iceServers.push(regIceServer);\n      }\n\n      peerConnectionConfig.iceTransportPolicy = 'relay';\n    } else {\n      // last priority using default ice servers.\n      if (instance.iceTransportPolicy) {\n        peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\n      }\n    }\n\n    console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\n\n    let peerConnection = new RTCPeerConnection(peerConnectionConfig);\n    instance.peerConnection = peerConnection;\n\n    // set local stream\n    instance.stream.getTracks().forEach(function (track) {\n      console.info(logHeader, 'Add Track To Peer Connection', track);\n      peerConnection.addTrack(track, instance.stream);\n    });\n\n    if (checkIOSVersion() >= 15) {\n      const formatNumber = getFormatNumber(offer.sdp, 'H264');\n\n      if (formatNumber > 0) {\n        offer.sdp = removeFormat(offer.sdp, formatNumber);\n      }\n    }\n\n    if (instance.connectionConfig.maxVideoBitrate) {\n      // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\n      offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\n    }\n\n    if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n      offer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, offer.sdp);\n    }\n\n    // Set up event handlers BEFORE setRemoteDescription to avoid missing events\n    peerConnection.onicecandidate = function (e) {\n      if (e.candidate && e.candidate.candidate) {\n        // console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\n        sendMessage(instance.webSocket, {\n          id: id,\n          peer_id: peerId,\n          command: 'candidate',\n          candidates: [e.candidate],\n        });\n      }\n    };\n\n    peerConnection.oniceconnectionstatechange = function (e) {\n      let state = peerConnection.iceConnectionState;\n\n      console.info(logHeader, 'ICE State', '[' + state + ']');\n      instance.iceLastEvent = e;\n\n      if (state === 'failed' && !instance.isManualStop) {\n        initRetryAfterLongEnoughIceDisconnect();\n      } else if (state === 'disconnected' && !instance.isManualStop) {\n        initRetryAfterLongEnoughIceDisconnect();\n      } else {\n        cancelRetryAfterLongEnoughIceDisconnect();\n      }\n\n      if (instance.callbacks.iceStateChange) {\n        try {\n          instance.callbacks.iceStateChange(state);\n        } catch (callbackError) {\n          console.error(logHeader, 'Error in iceStateChange callback', callbackError);\n        }\n      }\n\n      if (state === 'connected') {\n        if (instance.callbacks.connected) {\n          try {\n            instance.callbacks.connected(e);\n          } catch (callbackError) {\n            console.error(logHeader, 'Error in connected callback', callbackError);\n          }\n        }\n      }\n\n      if (state === 'failed' || state === 'disconnected' || state === 'closed') {\n        if (instance.callbacks.connectionClosed) {\n          try {\n            instance.callbacks.connectionClosed('ice', e);\n          } catch (callbackError) {\n            console.error(logHeader, 'Error in connectionClosed callback', callbackError);\n          }\n        }\n      }\n    };\n\n    peerConnection.onconnectionstatechange = async function (e) {\n      let state = peerConnection.connectionState;\n\n      /* A happy ending! */\n      if (state === 'connected') {\n        instance.error = null;\n        instance.webSocketCloseEvent = null;\n        instance.reconnectWebSocketPromise = null;\n      }\n    };\n\n    await peerConnection.setRemoteDescription(offer);\n    const answer = await peerConnection.createAnswer();\n\n    if (checkIOSVersion() >= 15) {\n      const formatNumber = getFormatNumber(answer.sdp, 'H264');\n\n      if (formatNumber > 0) {\n        answer.sdp = removeFormat(answer.sdp, formatNumber);\n      }\n    }\n\n    if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n      answer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, answer.sdp);\n    }\n\n    await peerConnection.setLocalDescription(answer);\n\n    // Add remote ICE candidates after setRemoteDescription completes\n    if (candidates) {\n      await addIceCandidate(peerConnection, candidates);\n    }\n\n    sendMessage(instance.webSocket, {\n      id: id,\n      peer_id: peerId,\n      command: 'answer',\n      sdp: answer,\n    });\n  }\n\n  async function addIceCandidate(peerConnection, candidates) {\n    for (let i = 0; i < candidates.length; i++) {\n      if (candidates[i] && candidates[i].candidate) {\n        let basicCandidate = candidates[i];\n\n        try {\n          await peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate));\n        } catch (error) {\n          console.error('peerConnection.addIceCandidate', basicCandidate, error);\n          errorHandler(error);\n        }\n      }\n    }\n  }\n\n  // instance methods\n  instance.attachMedia = function (videoElement: HTMLVideoElement) {\n    instance.videoElement = videoElement;\n  };\n\n  instance.getUserMedia = function (constraints?: MediaStreamConstraints) {\n    return getUserMedia(constraints);\n  };\n\n  instance.getDisplayMedia = function (constraints?: DisplayMediaStreamConstraints) {\n    return getDisplayMedia(constraints);\n  };\n\n  instance.switchCamera = function (deviceId: string) {\n    return switchCamera(deviceId);\n  };\n\n  instance.hasActiveConnection = function () {\n    return (\n      instance.peerConnection &&\n      !['closed', 'failed'].includes(instance.peerConnection.connectionState) &&\n      !['closed', 'failed'].includes(instance.peerConnection.iceConnectionState)\n    );\n  };\n\n  instance.startStreaming = function (connectionUrl: string, connectionConfig?: ConnectionConfig) {\n    instance.connectionUrl = connectionUrl + '?direction=send&transport=tcp';\n    console.info(logEventHeader, 'Start Streaming');\n\n    if (connectionConfig) {\n      instance.connectionConfig = connectionConfig;\n    }\n\n    instance.retriesUsed = 0;\n    instance.isManualStop = false;\n    initWebSocket();\n  };\n\n  instance.closePeerConnection = function () {\n    cancelRetryAfterLongEnoughIceDisconnect();\n    // first release peer connection with ome\n    if (instance.peerConnection) {\n      // remove tracks from peer connection\n      instance.peerConnection.getSenders().forEach(function (sender) {\n        instance.peerConnection.removeTrack(sender);\n      });\n\n      instance.peerConnection.close();\n      instance.peerConnection = null;\n    }\n  };\n\n  instance.closeWebSocket = function () {\n    if (instance.webSocket && instance.webSocket.readyState !== WebSocket.CLOSED) {\n      // [FIX] Clear callback early to prevent retry trigger in onclose\n      instance.webSocket.onclose = null;\n      instance.webSocket.onerror = null;\n      instance.webSocket.onmessage = null;\n\n      if (instance.connectionData) {\n        sendMessage(instance.webSocket, {\n          id: instance.connectionData.id,\n          peer_id: instance.connectionData.peerId,\n          command: 'stop',\n        });\n      }\n\n      instance.webSocket.close();\n      instance.webSocket = null;\n    }\n  };\n\n  instance.closeVideoAudioStreams = function () {\n    if (instance.stream) {\n      instance.stream.getTracks().forEach((track) => {\n        track.stop();\n        instance.stream.removeTrack(track);\n      });\n\n      if (instance.videoElement) {\n        instance.videoElement.srcObject = null;\n      }\n\n      instance.stream = null;\n    }\n  };\n\n  instance.remove = function () {\n    instance.isManualStop = true;\n    instance.closePeerConnection();\n    instance.closeVideoAudioStreams();\n    instance.closeWebSocket();\n    console.info(logEventHeader, 'Removed');\n  };\n}\n\n// static methods\nQencodeWebRTC.create = function (config: CreateConfig = {}) {\n  console.info('QencodeWebRTC ', '2025-12-22');\n  const instance = initConfig(config);\n  addMethod(instance);\n\n  return instance;\n};\n\nQencodeWebRTC.getDevices = async function (): Promise<Devices> {\n  await getStreamForDeviceCheck();\n  const deviceInfos = await getDevices();\n  return gotDevices(deviceInfos);\n};\n\nexport default QencodeWebRTC;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","sendMessage","webSocket","message","readyState","WebSocket","OPEN","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","checkIOSVersion","agent","window","navigator","userAgent","start","indexOf","Number","substr","replace","splitSdpLines","sdp","split","map","line","joinSdpLines","lines","join","getFormatNumber","format","formatNumber","i","length","toLowerCase","removeFormat","newLines","push","delayedCall","fn","args","delay","Promise","resolve","setTimeout","then","appendFmtp","fmtpStr","payloads","tokens","j","fmtpLineFound","addMethod","instance","errorHandler","error","callbacks","callbackError","console","async","replaceTracksInPeerConnection","newStream","peerConnection","replacedVideo","replacedAudio","oldVideoTrack","oldAudioTrack","newVideoTrack","newAudioTrack","pc","getVideoTracks","getAudioTracks","senders","getSenders","videoSender","find","s","track","kind","audioSender","replaceTrack","info","warn","replaceStream","stream","hasActiveConnection","oldStream","rep","forEach","t","stop","composed","MediaStream","addTrack","elem","videoElement","srcObject","onloadedmetadata","e","play","requestOffer","command","offerRequestCount","addRetryToQueue","isManualStop","reconnectWebSocketPromise","retryDelay","reconnectWebSocket","onLine","log","addEventListener","once","connectStarted","disconnected","includes","iceConnectionState","isFinite","retryMaxCount","retriesUsed","closePeerConnection","closeWebSocket","webSocketCloseEvent","initWebSocket","connectionUrl","onopen","onmessage","parse","data","id","peerId","offer","candidates","iceServers","connectionData","peerConnectionConfig","connectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","getTracks","maxVideoBitrate","media","bitrate","slice","concat","setBitrateLimit","onicecandidate","candidate","peer_id","oniceconnectionstatechange","state","iceLastEvent","timeout","iceDisconnectTimeoutId","initRetryAfterLongEnoughIceDisconnect","cancelRetryAfterLongEnoughIceDisconnect","iceStateChange","connected","connectionClosed","onconnectionstatechange","connectionState","setRemoteDescription","answer","createAnswer","setLocalDescription","basicCandidate","addIceCandidate","RTCIceCandidate","createPeerConnection","ice_servers","onerror","onclose","event","code","clearTimeout","attachMedia","getUserMedia","constraints","video","deviceId","undefined","audio","mediaDevices","catch","getDisplayMedia","switchCamera","finalVideoConstraints","width","ideal","height","aspectRatio","exact","shouldRequestAudio","newCamStream","getUserMediaError","fallback","existingAudio","startStreaming","sender","removeTrack","close","CLOSED","closeVideoAudioStreams","remove","create","config","initConfig","getDevices","getStreamForDeviceCheck","deviceInfos","devices","audioinput","audiooutput","videoinput","other","deviceInfo","label","gotDevices","enumerateDevices"],"sourceRoot":""}