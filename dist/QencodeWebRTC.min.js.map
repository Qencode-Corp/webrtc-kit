{"version":3,"file":"QencodeWebRTC.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAuB,cAAID,IAE3BD,EAAoB,cAAIC,IAR1B,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCAlF,MAAMI,EAAgB,GAEhBC,EAAY,qBACZC,EAAiB,qBAGvB,SAASC,EAAYC,EAAWC,GAExBD,GACAA,EAAUE,KAAKC,KAAKC,UAAUH,IAItC,SAASI,EAAsBC,GAC3B,IACIC,EADAC,EAAS,GAMb,OAJID,EAAQD,EAAIC,MAAM,8DAClBC,EAASD,EAAM,IAGZC,EAGX,SAASC,EAAOC,GAEZ,IACIH,EADAC,EAAS,GAOb,OAJID,EAAQG,EAAOH,MAAM,IAAII,OAAO,0KAA2K,UAC3MH,EAASD,EAAM,IAGZC,EAGX,SAASI,IACL,IAAIC,EAAQC,OAAOC,UAAUC,UACzBC,EAAQJ,EAAMK,QAAQ,OAC1B,OAAKL,EAAMK,QAAQ,WAAa,GAAKL,EAAMK,QAAQ,SAAW,IAAMD,GAAS,EAClEH,OAAOK,OAAON,EAAMO,OAAOH,EAAQ,EAAG,GAAGI,QAAQ,IAAK,MAE1D,EAIX,SAASC,EAAcC,GAEnB,OAAOA,EAAIC,MAAM,SAASC,KAAIC,GAAQA,EAAKL,QAAQ,MAAO,MAG9D,SAASM,EAAaC,GAElB,OAAOA,EAAMC,KAAK,QAUtB,SAASC,EAAgBP,EAAKQ,GAE1B,MAAMH,EAAQN,EAAcC,GAC5B,IAAIS,GAAgB,EAEpB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAMM,OAAS,EAAGD,IAIlC,GAFAL,EAAMK,GAAKL,EAAMK,GAAGE,cAEhBP,EAAMK,GAAGf,QAAQ,aAAe,GAAKU,EAAMK,GAAGf,QAAQa,EAAOI,gBAAkB,EAAG,CAElFH,EAAeJ,EAAMK,GAAGT,MAAM,KAAK,GAAGA,MAAM,KAAK,GACjD,MAIR,OAAOQ,EAGX,SAASI,EAAab,EAAKS,GACvB,IAAIK,EAAW,GACXT,EAAQN,EAAcC,GAE1B,IAAK,IAAIU,EAAI,EAAGA,EAAIL,EAAMM,OAAQD,IAEM,IAAhCL,EAAMK,GAAGf,QAAQ,WACjBmB,EAASC,KAAKV,EAAMK,GAAGZ,QAAQ,IAAMW,EAAmB,KACjDJ,EAAMK,GAAGf,QAAQc,EAAe,KAAO,GAG9CK,EAASC,KAAKV,EAAMK,IAI5B,OAAON,EAAaU,GAutBxBzC,EAAc2C,OAAS,SAAUC,GAE7BC,QAAQC,KAAK5C,EAAgB,iBAE7B,IAAI6C,EAAW,CACbC,cAAe,EACfC,WAAY,IAGdF,UAAoB,GAKpB,OAzqBJ,SAAoBA,EAAUH,GAE1BG,EAASG,OAAS,KAClBH,EAAS3C,UAAY,KACrB2C,EAASI,eAAiB,KAC1BJ,EAASK,iBAAmB,GAE5BL,EAASM,OAAS,WAElBN,EAASO,aAAe,KACxBP,EAASQ,cAAgB,KAErBX,GAAWA,EAAQY,UAEnBT,EAASS,UAAYZ,EAAQY,UAE7BT,EAASS,UAAY,GAspBzBC,CAAWV,EAAUH,GAxoBzB,SAAmBG,GAEf,SAASW,EAAaC,GAEdZ,EAASS,UAAUG,OAEnBZ,EAASS,UAAUG,MAAMA,GA+IjC,SAASC,EAAcL,GAEnB,IAAKA,EAED,YADAG,EAAa,6BAIjBX,EAASQ,cAAgBA,EAEzB,IAAInD,EAAY,KAEhB,IAEIA,EAAY,IAAIyD,UAAUN,GAC5B,MAAOI,GAELD,EAAaC,GAIjBZ,EAAS3C,UAAYA,EAErBA,EAAU0D,OAAS,WAGf3D,EAAYC,EAAW,CACnB2D,QAAS,mBAIjB3D,EAAU4D,UAAY,SAAUC,GAE5B,IAAI5D,EAAUE,KAAK2D,MAAMD,EAAEE,MAEvB9D,EAAQsD,QACRd,QAAQc,MAAM,sBAAuBtD,EAAQsD,OAC7CD,EAAarD,EAAQsD,QAGD,UAApBtD,EAAQ0D,SA0GpB,SAA8BK,EAAIC,EAAQC,EAAOC,EAAYC,GAEzDtD,OAAOuD,eAAiB,CACpBL,GAAAA,EACAC,OAAAA,GAGJ,IAAIK,EAAuB,GAE3B,GAAI3B,EAASK,iBAAiBoB,WAG1BE,EAAqBF,WAAazB,EAASK,iBAAiBoB,WAExDzB,EAASK,iBAAiBuB,qBAE1BD,EAAqBC,mBAAqB5B,EAASK,iBAAiBuB,yBAErE,GAAIH,EAAY,CAGnBE,EAAqBF,WAAa,GAElC,IAAK,IAAInC,EAAI,EAAGA,EAAImC,EAAWlC,OAAQD,IAAK,CAExC,IAAIuC,EAAYJ,EAAWnC,GAEvBwC,EAAe,GAEnBA,EAAaC,KAAOF,EAAUE,KAE9B,IAAIC,GAAkB,EAClBC,EAAevE,EAAsBsC,EAASQ,eAElD,IAAK,IAAI0B,EAAI,EAAGA,EAAIJ,EAAaC,KAAKxC,OAAQ2C,IAI1C,GAFgBJ,EAAaC,KAAKG,GAEpB3D,QAAQ0D,IAAiB,EAAG,CACtCD,GAAkB,EAClB,MAIR,IAAKA,GAEGF,EAAaC,KAAKxC,OAAS,EAAG,CAE9B,IAAI4C,EAAiBL,EAAaC,KAAK,GACnCK,EAAKtE,EAAOqE,GAEZF,GAAgBG,GAChBN,EAAaC,KAAKpC,KAAKwC,EAAezD,QAAQ0D,EAAIH,IAK9DH,EAAaO,SAAWR,EAAUS,UAClCR,EAAaS,WAAaV,EAAUU,WAEpCZ,EAAqBF,WAAW9B,KAAKmC,GAGzCH,EAAqBC,mBAAqB,aAItC5B,EAAS4B,qBAETD,EAAqBC,mBAAqB5B,EAAS4B,oBA6B3D9B,QAAQC,KAAK7C,EAAW,qCAAsCyE,GAE9D,IAAIvB,EAAiB,IAAIoC,kBAAkBb,GAY3C,GAVA3B,EAASI,eAAiBA,EAG1BJ,EAASG,OAAOsC,YAAYC,SAAQ,SAAUC,GAE1C7C,QAAQC,KAAK7C,EAAW,+BAAgCyF,GACxDvC,EAAewC,SAASD,EAAO3C,EAASG,WAIxClC,KAAqB,GAAI,CACzB,MAAMoB,EAAeF,EAAgBoC,EAAM3C,IAAK,QAE5CS,EAAe,IACfkC,EAAM3C,IAAMa,EAAa8B,EAAM3C,IAAKS,IAIxCW,EAASK,iBAAiBwC,kBAG1BtB,EAAM3C,IAtTd,SAAyBA,EAAKkE,EAAOC,GAEjC,IAAI9D,EAAQN,EAAcC,GACtBG,GAAQ,EAEZ,IAAK,IAAIO,EAAI,EAAGA,EAAIL,EAAMM,OAAQD,IAC9B,GAAuC,IAAnCL,EAAMK,GAAGf,QAAQ,WAAqB,CACtCQ,EAAOO,EACP,MAGR,IAAc,IAAVP,EAEA,OAAOH,EAOX,IAHAG,IAGqC,IAA9BE,EAAMF,GAAMR,QAAQ,OAA6C,IAA9BU,EAAMF,GAAMR,QAAQ,OAE1DQ,IAIJ,GAAiC,IAA7BE,EAAMF,GAAMR,QAAQ,KAIpB,OAFAU,EAAMF,GAAQ,QAAUgE,EAEjB/D,EAAaC,GAIxB,IAAIS,EAAWT,EAAM+D,MAAM,EAAGjE,GAK9B,OAHAW,EAASC,KAAK,QAAUoD,GACxBrD,EAAWA,EAASuD,OAAOhE,EAAM+D,MAAMjE,EAAME,EAAMM,SAE5CP,EAAaU,GA+QJwD,CAAgB3B,EAAM3C,IAAK,EAASoB,EAASK,iBAAiBwC,kBAG1E7C,EAASK,iBAAiBzB,KAAOoB,EAASK,iBAAiBzB,IAAIuE,aAE/D5B,EAAM3C,IAAMuE,EAAW5B,EAAM3C,MAEjCkB,QAAQsD,IAAI,SAAU7B,EAAOA,EAAM3C,KA1iB3C,SAA4B2C,GACtBA,GAAS/E,OAAO6G,OAAO9B,EAAO,QAAgC,iBAAfA,GAAO3C,KACjD2C,EAAM3C,IAAIF,QAAQ,SAAU,QA0iBjC4E,CAAmB/B,GAGnBnB,EAAemD,eAAiB,SAAUrC,GAEhCA,EAAEsC,WAAatC,EAAEsC,UAAUA,YAE3B1D,QAAQC,KAAK7C,EAAW,iBAAkB,KAAMgE,EAAEsC,UAAUA,UAAW,KAAMtC,GAE7E9D,EAAY4C,EAAS3C,UAAW,CAC5BgE,GAAIA,EACJoC,QAASnC,EACTN,QAAS,YACTQ,WAAY,CAACN,EAAEsC,eAK3BpD,EAAesD,2BAA6B,SAAUxC,GAElD,IAAIyC,EAAQvD,EAAewD,mBAEvB5D,EAASS,UAAUoD,iBAEnB/D,QAAQC,KAAK7C,EAAW,YAAa,IAAMyG,EAAQ,KACnD3D,EAASS,UAAUoD,eAAeF,IAGxB,cAAVA,GAEI3D,EAASS,UAAUqD,YAEnBhE,QAAQC,KAAK7C,EAAW,0BAA2BgE,GACnDlB,EAASS,UAAUqD,UAAU5C,IAIvB,WAAVyC,GAAgC,iBAAVA,GAAsC,WAAVA,GAE9C3D,EAASS,UAAUsD,mBAEnBjE,QAAQc,MAAM1D,EAAW,uBAAwBgE,GACjDlB,EAASS,UAAUsD,iBAAiB,MAAO7C,KAKzDd,EAAe4D,qBAAqBzC,GAC7B0C,MAAK,WAEF7D,EAAe8D,eACVD,MAAK,SAAUE,GAEZ,GAAIlG,KAAqB,GAAI,CAEzB,MAAMoB,EAAeF,EAAgBgF,EAAOvF,IAAK,QAE7CS,EAAe,IAEf8E,EAAOvF,IAAMa,EAAa0E,EAAOvF,IAAKS,IAI1CW,EAASK,iBAAiBzB,KAAOoB,EAASK,iBAAiBzB,IAAIuE,aAE/DgB,EAAOvF,IAAMuE,EAAWgB,EAAOvF,MAEnCkB,QAAQsD,IAAI,UAAWe,EAAQA,EAAOvF,KAEtCwB,EAAegE,oBAAoBD,GAC9BF,MAAK,WAEF7G,EAAY4C,EAAS3C,UAAW,CAC5BgE,GAAIA,EACJoC,QAASnC,EACTN,QAAS,SACTpC,IAAKuF,OAGZE,OAAM,SAAUzD,GAEbd,QAAQc,MAAM,qCAAsCA,GACpDD,EAAaC,SAGxByD,OAAM,SAAUzD,GAEbd,QAAQc,MAAM,8BAA+BA,GAC7CD,EAAaC,SAGxByD,OAAM,SAAUzD,GAEbd,QAAQc,MAAM,sCAAuCA,GACrDD,EAAaC,MAGjBY,GAMR,SAAyBpB,EAAgBoB,GACrC1B,QAAQsD,IAAI,kBAAmBhD,EAAgBoB,GAC/C,IAAK,IAAIlC,EAAI,EAAGA,EAAIkC,EAAWjC,OAAQD,IAEnC,GAAIkC,EAAWlC,IAAMkC,EAAWlC,GAAGkE,UAAW,CAE1C,IAAIc,EAAiB9C,EAAWlC,GAEhCc,EAAemE,gBAAgB,IAAIC,gBAAgBF,IAC9CL,MAAK,eAGLI,OAAM,SAAUzD,GAEbd,QAAQc,MAAM,iCAAkC0D,EAAgB1D,GAChED,EAAaC,OAnBzB2D,CAAgBnE,EAAgBoB,GA9U5BiD,CACInH,EAAQ+D,GACR/D,EAAQmG,QACRnG,EAAQsB,IACRtB,EAAQkE,WACRlE,EAAQoH,cAKpBrH,EAAUsH,QAAUC,eAAgBhE,GAlN5C,IAAqBiE,EAAIC,EAAMC,EAoNnBjF,QAAQc,MAAM,oBAAqBA,GACnCD,EAAaC,GACbZ,EAASgF,aAAe,GAGrBhF,EAASiF,WACTjF,EAASkF,UACV1G,OAAO2G,SAASnF,EAASE,aACzB1B,OAAO2G,SAASnF,EAASC,gBACzBD,EAASgF,YAAchF,EAASC,gBAEhCD,EAASgF,aAAe,EACxBhF,EAASkF,UAAW,EACpBpF,QAAQsD,IAAI,0BAA0BpD,EAASgF,eAG3C3H,GAAaA,EAAU+H,aAAetE,UAAUuE,SAClDhI,EAAUsH,QAAU,KACpBtH,EAAUiI,QAAU,KACpBjI,EAAU4D,UAAY,KACtB5D,EAAU0D,OAAS,KACnB1D,EAAUkI,eAzOLV,EA4OWhE,EA5OPiE,EA4OsB,CAACtE,GA5OjBuE,EA4OiC/E,EAASE,WA3OhE,IAAIsF,SAAQC,IACjBC,YAAW,KACT,MAAM7H,EAASgH,KAAMC,GACrBW,EAAQ5H,KACPkH,OAwOO/E,EAASkF,UAAW,IAI1B7H,EAAUiI,QAAU,SAAUpE,GAErBlB,EAASiF,UAENjF,EAASS,UAAUsD,kBAEnB/D,EAASS,UAAUsD,iBAAiB,YAAa7C,IAOjE,SAASiC,EAAWvE,GAEhB,MAAM+G,EAAU3F,EAASK,iBAAiBzB,IAAIuE,WAExClE,EAAQN,EAAcC,GACtBgH,EAAW,GAEjB,IAAK,IAAItG,EAAI,EAAGA,EAAIL,EAAMM,OAAQD,IAE9B,GAAoC,IAAhCL,EAAMK,GAAGf,QAAQ,WAAkB,CAEnC,IAAIsH,EAAS5G,EAAMK,GAAGT,MAAM,KAE5B,IAAK,IAAIqD,EAAI,EAAGA,EAAI2D,EAAOtG,OAAQ2C,IAE/B0D,EAASjG,KAAKkG,EAAO3D,IAGzB,MAIR,IAAK,IAAI5C,EAAI,EAAGA,EAAIsG,EAASrG,OAAQD,IAAK,CAEtC,IAAIwG,GAAgB,EAEpB,IAAK,IAAI5D,EAAI,EAAGA,EAAIjD,EAAMM,OAAQ2C,IAEoB,IAA9CjD,EAAMiD,GAAG3D,QAAQ,UAAYqH,EAAStG,MACtCwG,GAAgB,EAChB7G,EAAMiD,IAAM,IAAMyD,GAI1B,IAAKG,EAED,IAAK,IAAI5D,EAAI,EAAGA,EAAIjD,EAAMM,OAAQ2C,IAEsB,IAAhDjD,EAAMiD,GAAG3D,QAAQ,YAAcqH,EAAStG,MAExCL,EAAMiD,IAAM,cAAgB0D,EAAStG,GAAK,IAAMqG,GAMhE,OAAO3G,EAAaC,GAoQxBe,EAAS+F,YAAc,SAAUxF,GAE7BP,EAASO,aAAeA,GAG5BP,EAASgG,aAAe,SAAUC,GAE9B,OApiBJ,SAAsBA,GAgBlB,OAdKA,IAEDA,EAAc,CACVC,MAAO,CACHC,cAAUC,GAEdC,MAAO,CACHF,cAAUC,KAKtBtG,QAAQC,KAAK7C,EAAW,wCAAyC+I,GAE1D7H,UAAUkI,aAAaN,aAAaC,GACtChC,MAAK,SAAU9D,GAEZL,QAAQC,KAAK7C,EAAW,0CAA2CiD,GAEnEH,EAASG,OAASA,EAElB,IAAIoG,EAAOvG,EAASO,aAapB,OAVIgG,IAEAA,EAAKC,UAAYrG,EAEjBoG,EAAKE,iBAAmB,SAAUvF,GAE9BqF,EAAKG,SAIN,IAAIlB,SAAQ,SAAUC,GAEzBA,EAAQtF,SAGfkE,OAAM,SAAUzD,GAKb,OAHAd,QAAQc,MAAM1D,EAAW,2CAA6C0D,GACtED,EAAaC,GAEN,IAAI4E,SAAQ,SAAUC,EAASkB,GAClCA,EAAO/F,SAqfZoF,CAAaC,IAGxBjG,EAAS4G,gBAAkB,SAAUX,GAEjC,OArfJ,SAAyBA,GAQrB,OANKA,IACDA,EAAc,IAGlBnG,QAAQC,KAAK7C,EAAW,kCAAmC+I,GAEpD7H,UAAUkI,aAAaM,gBAAgBX,GACzChC,MAAK,SAAU9D,GAEZL,QAAQC,KAAK7C,EAAW,qCAAsCiD,GAE9DH,EAASG,OAASA,EAElB,IAAIoG,EAAOvG,EAASO,aAapB,OAVIgG,IAEAA,EAAKC,UAAYrG,EAEjBoG,EAAKE,iBAAmB,SAAUvF,GAE9BqF,EAAKG,SAIN,IAAIlB,SAAQ,SAAUC,GAEzBA,EAAQtF,SAGfkE,OAAM,SAAUzD,GAKb,OAHAd,QAAQc,MAAM1D,EAAW,sCAAwC0D,GACjED,EAAaC,GAEN,IAAI4E,SAAQ,SAAUC,EAASkB,GAClCA,EAAO/F,SA8cZgG,CAAgBX,IAG3BjG,EAAS6G,eAAiB,SAAUrG,EAAeH,GAE/CG,GAAe,gCAEfV,QAAQC,KAAK5C,EAAgB,mBAEzBkD,IAEAL,EAASK,iBAAmBA,GAGhCL,EAASgF,YAAc,EACvBnE,EAAcL,IAGlBR,EAAS8G,OAAS,WAEd9G,EAASiF,UAAW,EAGhBjF,EAASI,iBAGTJ,EAASI,eAAe2G,aAAarE,SAAQ,SAAUsE,GACnDhH,EAASI,eAAe6G,YAAYD,MAGxChH,EAASI,eAAemF,QACxBvF,EAASI,eAAiB,YACnBJ,EAASI,gBAIhBJ,EAASG,SAETH,EAASG,OAAOsC,YAAYC,SAAQC,IAEhCA,EAAMuE,OACNlH,EAASG,OAAO8G,YAAYtE,MAG5B3C,EAASO,eACTP,EAASO,aAAaiG,UAAY,MAGtCxG,EAASG,OAAS,YACXH,EAASG,QAIhBH,EAAS3C,YAETD,EAAY4C,EAAS3C,UAAW,CAC5BgE,GAAIlD,OAAOuD,eAAeL,GAC1BoC,QAAStF,OAAOuD,eAAeJ,OAC/BN,QAAS,SAGbhB,EAAS3C,UAAUkI,QACnBvF,EAAS3C,UAAY,YACd2C,EAAS3C,WAGpB2C,EAASM,OAAS,UAElBR,QAAQC,KAAK5C,EAAgB,YAkBjCgK,CAAUnH,GAEHA,GAGX/C,EAAcmK,WAAaxC,iBAIvB,aAzuBJA,iBAQI,aAAaxG,UAAUkI,aAAaN,aALhB,CAChBK,MAAO,CAAEF,cAAUC,GACnBF,MAAO,CAAEC,cAAUC,EAAWiB,MAAO,KAAMC,OAAQ,QAkuBjDC,GArtBV,SAAoBC,GAEhB,IAAIC,EAAU,CACV,WAAc,GACd,YAAe,GACf,WAAc,GACd,MAAS,IAGb,IAAK,IAAInI,EAAI,EAAGA,IAAMkI,EAAYjI,SAAUD,EAAG,CAE3C,MAAMoI,EAAaF,EAAYlI,GAE/B,IAAIS,EAAO,GAEXA,EAAKoG,SAAWuB,EAAWvB,SAEH,eAApBuB,EAAWC,MAEX5H,EAAK6H,MAAQF,EAAWE,OAAS,cAAcH,EAAQI,WAAWtI,OAAS,IAC3EkI,EAAQI,WAAWlI,KAAKI,IACG,gBAApB2H,EAAWC,MAElB5H,EAAK6H,MAAQF,EAAWE,OAAS,WAAWH,EAAQK,YAAYvI,OAAS,IACzEkI,EAAQK,YAAYnI,KAAKI,IACE,eAApB2H,EAAWC,MAElB5H,EAAK6H,MAAQF,EAAWE,OAAS,UAAUH,EAAQM,WAAWxI,OAAS,IACvEkI,EAAQM,WAAWpI,KAAKI,KAGxBA,EAAK6H,MAAQF,EAAWE,OAAS,SAASH,EAAQO,MAAMzI,OAAS,IACjEkI,EAAQO,MAAMrI,KAAKI,IAI3B,OAAO0H,EAmrBAQ,OA9tBXrD,iBAEI,aAAaxG,UAAUkI,aAAa4B,mBA2tBVd,KAI9B,U","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const QencodeWebRTC = {};\n\nconst logHeader = 'QencodeWebRTC.js :';\nconst logEventHeader = 'QencodeWebRTC.js :';\n\n// private methods\nfunction sendMessage(webSocket, message) {\n\n    if (webSocket) {\n        webSocket.send(JSON.stringify(message));\n    }\n}\n\nfunction generateDomainFromUrl(url) {\n    let result = '';\n    let match;\n    if (match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im)) {\n        result = match[1];\n    }\n\n    return result;\n}\n\nfunction findIp(string) {\n\n    let result = '';\n    let match;\n\n    if (match = string.match(new RegExp('\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b', 'gi'))) {\n        result = match[0];\n    }\n\n    return result;\n}\n\nfunction checkIOSVersion() {\n    var agent = window.navigator.userAgent,\n        start = agent.indexOf('OS ');\n    if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\n        return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\n    }\n    return 0;\n}\n\n// SDP helper functions to properly handle CRLF line endings (RFC 4566)\nfunction splitSdpLines(sdp) {\n    // Normalize line endings: split on \\r\\n or \\n, and remove trailing \\r from each line\n    return sdp.split(/\\r?\\n/).map(line => line.replace(/\\r$/, ''));\n}\n\nfunction joinSdpLines(lines) {\n    // Join with CRLF as required by SDP specification (RFC 4566)\n    return lines.join('\\r\\n');\n}\n\n/* Just in case. */\nfunction normalizeSdpObject(offer) {\n  if (offer && Object.hasOwn(offer, 'sdp') && typeof offer?.sdp === 'string') {\n    return offer.sdp.replace(/\\r?\\n/g, \"\\r\\n\");\n  }\n}\n\nfunction getFormatNumber(sdp, format) {\n\n    const lines = splitSdpLines(sdp);\n    let formatNumber = -1;\n\n    for (let i = 0; i < lines.length - 1; i++) {\n\n        lines[i] = lines[i].toLowerCase();\n\n        if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\n            // parsing \"a=rtpmap:100 H264/90000\" line\n            formatNumber = lines[i].split(' ')[0].split(':')[1];\n            break;\n        }\n    }\n\n    return formatNumber;\n}\n\nfunction removeFormat(sdp, formatNumber) {\n    let newLines = [];\n    let lines = splitSdpLines(sdp);\n\n    for (let i = 0; i < lines.length; i++) {\n\n        if (lines[i].indexOf('m=video') === 0) {\n            newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\n        } else if (lines[i].indexOf(formatNumber + '') > -1) {\n\n        } else {\n            newLines.push(lines[i]);\n        }\n    }\n\n    return joinSdpLines(newLines)\n}\n\nasync function getStreamForDeviceCheck() {\n\n    // High resolution video constraints makes browser to get maximum resolution of video device.\n    const constraints = {\n        audio: { deviceId: undefined },\n        video: { deviceId: undefined, width: 1920, height: 1080 }\n    };\n\n    return await navigator.mediaDevices.getUserMedia(constraints);\n}\n\nasync function getDevices() {\n\n    return await navigator.mediaDevices.enumerateDevices();\n\n\n}\n\nfunction gotDevices(deviceInfos) {\n\n    let devices = {\n        'audioinput': [],\n        'audiooutput': [],\n        'videoinput': [],\n        'other': [],\n    };\n\n    for (let i = 0; i !== deviceInfos.length; ++i) {\n\n        const deviceInfo = deviceInfos[i];\n\n        let info = {};\n\n        info.deviceId = deviceInfo.deviceId;\n\n        if (deviceInfo.kind === 'audioinput') {\n\n            info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\n            devices.audioinput.push(info);\n        } else if (deviceInfo.kind === 'audiooutput') {\n\n            info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\n            devices.audiooutput.push(info);\n        } else if (deviceInfo.kind === 'videoinput') {\n\n            info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\n            devices.videoinput.push(info);\n        } else {\n\n            info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\n            devices.other.push(info);\n        }\n    }\n\n    return devices;\n}\n\nfunction initConfig(instance, options) {\n\n    instance.stream = null;\n    instance.webSocket = null;\n    instance.peerConnection = null;\n    instance.connectionConfig = {};\n\n    instance.status = 'creating';\n\n    instance.videoElement = null;\n    instance.connectionUrl = null;\n\n    if (options && options.callbacks) {\n\n        instance.callbacks = options.callbacks;\n    } else {\n        instance.callbacks = {};\n    }\n\n}\n\nfunction delayedCall(fn, args, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const result = fn(...args);\n      resolve(result);\n    }, delay);\n  });\n}\n\nfunction addMethod(instance) {\n\n    function errorHandler(error) {\n\n        if (instance.callbacks.error) {\n\n            instance.callbacks.error(error);\n        }\n    }\n\n    function getUserMedia(constraints) {\n\n        if (!constraints) {\n\n            constraints = {\n                video: {\n                    deviceId: undefined\n                },\n                audio: {\n                    deviceId: undefined\n                }\n            };\n        }\n\n        console.info(logHeader, 'Requested Constraint To Input Devices', constraints);\n\n        return navigator.mediaDevices.getUserMedia(constraints)\n            .then(function (stream) {\n\n                console.info(logHeader, 'Received Media Stream From Input Device', stream);\n\n                instance.stream = stream;\n\n                let elem = instance.videoElement;\n\n                // Attach stream to video element when video element is provided.\n                if (elem) {\n\n                    elem.srcObject = stream;\n\n                    elem.onloadedmetadata = function (e) {\n\n                        elem.play();\n                    };\n                }\n\n                return new Promise(function (resolve) {\n\n                    resolve(stream);\n                });\n            })\n            .catch(function (error) {\n\n                console.error(logHeader, 'Can\\'t Get Media Stream From Input Device', error);\n                errorHandler(error);\n\n                return new Promise(function (resolve, reject) {\n                    reject(error);\n                });\n            });\n    }\n\n    function getDisplayMedia(constraints) {\n\n        if (!constraints) {\n            constraints = {};\n        }\n\n        console.info(logHeader, 'Requested Constraint To Display', constraints);\n\n        return navigator.mediaDevices.getDisplayMedia(constraints)\n            .then(function (stream) {\n\n                console.info(logHeader, 'Received Media Stream From Display', stream);\n\n                instance.stream = stream;\n\n                let elem = instance.videoElement;\n\n                // Attach stream to video element when video element is provided.\n                if (elem) {\n\n                    elem.srcObject = stream;\n\n                    elem.onloadedmetadata = function (e) {\n\n                        elem.play();\n                    };\n                }\n\n                return new Promise(function (resolve) {\n\n                    resolve(stream);\n                });\n            })\n            .catch(function (error) {\n\n                console.error(logHeader, 'Can\\'t Get Media Stream From Display', error);\n                errorHandler(error);\n\n                return new Promise(function (resolve, reject) {\n                    reject(error);\n                });\n            });\n    }\n\n    // From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\n    function setBitrateLimit(sdp, media, bitrate) {\n\n        let lines = splitSdpLines(sdp);\n        let line = -1;\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].indexOf('m=' + media) === 0) {\n                line = i;\n                break;\n            }\n        }\n        if (line === -1) {\n            // Could not find the m line for media\n            return sdp;\n        }\n\n        // Pass the m line\n        line++;\n\n        // Skip i and c lines\n        while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\n\n            line++;\n        }\n\n        // If we're on a b line, replace it\n        if (lines[line].indexOf('b') === 0) {\n\n            lines[line] = 'b=AS:' + bitrate;\n\n            return joinSdpLines(lines);\n        }\n\n        // Add a new b line\n        let newLines = lines.slice(0, line)\n\n        newLines.push('b=AS:' + bitrate)\n        newLines = newLines.concat(lines.slice(line, lines.length))\n\n        return joinSdpLines(newLines)\n    }\n\n    function initWebSocket(connectionUrl) {\n\n        if (!connectionUrl) {\n            errorHandler('connectionUrl is required');\n            return;\n        }\n\n        instance.connectionUrl = connectionUrl;\n\n        let webSocket = null;\n\n        try {\n\n            webSocket = new WebSocket(connectionUrl);\n        } catch (error) {\n\n            errorHandler(error);\n        }\n\n\n        instance.webSocket = webSocket;\n\n        webSocket.onopen = function () {\n\n            // Request offer at the first time.\n            sendMessage(webSocket, {\n                command: 'request_offer'\n            });\n        };\n\n        webSocket.onmessage = function (e) {\n\n            let message = JSON.parse(e.data);\n\n            if (message.error) {\n                console.error('webSocket.onmessage', message.error);\n                errorHandler(message.error);\n            }\n\n            if (message.command === 'offer') {\n\n                // OME returns offer. Start create peer connection.\n                createPeerConnection(\n                    message.id,\n                    message.peer_id,\n                    message.sdp,\n                    message.candidates,\n                    message.ice_servers\n                );\n            }\n        };\n\n        webSocket.onerror = async function (error) {\n\n            console.error('webSocket.onerror', error);\n            errorHandler(error);\n            instance.retriesUsed |= 0;\n            \n            if (\n              !instance.removing &&\n              !instance.retrying &&\n              Number.isFinite(instance.retryDelay) &&\n              Number.isFinite(instance.retryMaxCount) &&\n              instance.retriesUsed < instance.retryMaxCount\n              ) {\n              instance.retriesUsed += 1;\n              instance.retrying = true; /* Prevent multiple concurrent retries if onerror runs too often. */\n              console.log(`Starting retry attempt ${instance.retriesUsed}`);\n              \n              // Close the failed WebSocket before retrying\n              if (webSocket && webSocket.readyState !== WebSocket.CLOSED) {\n                webSocket.onerror = null; // Remove handlers to prevent stale events\n                webSocket.onclose = null;\n                webSocket.onmessage = null;\n                webSocket.onopen = null;\n                webSocket.close();\n              }\n              \n              await delayedCall(initWebSocket, [connectionUrl], instance.retryDelay);\n              instance.retrying = false;\n            }\n        };\n\n        webSocket.onclose = function (e) {\n\n            if (!instance.removing) {\n\n                if (instance.callbacks.connectionClosed) {\n\n                    instance.callbacks.connectionClosed('websocket', e);\n                }\n            }\n        };\n\n    }\n\n    function appendFmtp(sdp) {\n\n        const fmtpStr = instance.connectionConfig.sdp.appendFmtp;\n\n        const lines = splitSdpLines(sdp);\n        const payloads = [];\n\n        for (let i = 0; i < lines.length; i++) {\n\n            if (lines[i].indexOf('m=video') === 0) {\n\n                let tokens = lines[i].split(' ')\n\n                for (let j = 3; j < tokens.length; j++) {\n\n                    payloads.push(tokens[j]);\n                }\n\n                break;\n            }\n        }\n\n        for (let i = 0; i < payloads.length; i++) {\n\n            let fmtpLineFound = false;\n\n            for (let j = 0; j < lines.length; j++) {\n\n                if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\n                    fmtpLineFound = true;\n                    lines[j] += ';' + fmtpStr;\n                }\n            }\n\n            if (!fmtpLineFound) {\n\n                for (let j = 0; j < lines.length; j++) {\n\n                    if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\n\n                        lines[j] += '\\r\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\n                    }\n                }\n            }\n        }\n\n        return joinSdpLines(lines)\n    }\n\n    function createPeerConnection(id, peerId, offer, candidates, iceServers) {\n\n        window.connectionData = {\n            id,\n            peerId\n        }\n\n        let peerConnectionConfig = {};\n\n        if (instance.connectionConfig.iceServers) {\n\n            // first priority using ice servers from local config.\n            peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\n\n            if (instance.connectionConfig.iceTransportPolicy) {\n\n                peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\n            }\n        } else if (iceServers) {\n\n            // second priority using ice servers from ome and force using TCP\n            peerConnectionConfig.iceServers = [];\n\n            for (let i = 0; i < iceServers.length; i++) {\n\n                let iceServer = iceServers[i];\n\n                let regIceServer = {};\n\n                regIceServer.urls = iceServer.urls;\n\n                let hasWebSocketUrl = false;\n                let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\n\n                for (let j = 0; j < regIceServer.urls.length; j++) {\n\n                    let serverUrl = regIceServer.urls[j];\n\n                    if (serverUrl.indexOf(webSocketUrl) > -1) {\n                        hasWebSocketUrl = true;\n                        break;\n                    }\n                }\n\n                if (!hasWebSocketUrl) {\n\n                    if (regIceServer.urls.length > 0) {\n\n                        let cloneIceServer = regIceServer.urls[0];\n                        let ip = findIp(cloneIceServer);\n\n                        if (webSocketUrl && ip) {\n                            regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\n                        }\n                    }\n                }\n\n                regIceServer.username = iceServer.user_name;\n                regIceServer.credential = iceServer.credential;\n\n                peerConnectionConfig.iceServers.push(regIceServer);\n            }\n\n            peerConnectionConfig.iceTransportPolicy = 'relay';\n        } else {\n            // last priority using default ice servers.\n\n            if (instance.iceTransportPolicy) {\n\n                peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\n            }\n        }\n\n        let advancedSetting = {\n            optional: [\n                {\n                    googHighStartBitrate: {\n                        exact: !0\n                    }\n                },\n                {\n                    googPayloadPadding: {\n                        exact: !0\n                    }\n                },\n                {\n                    googScreencastMinBitrate: {\n                        exact: 500\n                    }\n                },\n                {\n                    enableDscp: {\n                        exact: true\n                    }\n                }\n            ]\n        };\n\n        console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\n\n        let peerConnection = new RTCPeerConnection(peerConnectionConfig);\n\n        instance.peerConnection = peerConnection;\n\n        // set local stream\n        instance.stream.getTracks().forEach(function (track) {\n\n            console.info(logHeader, 'Add Track To Peer Connection', track);\n            peerConnection.addTrack(track, instance.stream);\n        });\n\n\n        if (checkIOSVersion() >= 15) {\n            const formatNumber = getFormatNumber(offer.sdp, 'H264');\n\n            if (formatNumber > 0) {\n                offer.sdp = removeFormat(offer.sdp, formatNumber);\n            }\n        }\n\n        if (instance.connectionConfig.maxVideoBitrate) {\n\n            // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\n            offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\n        }\n\n        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n\n            offer.sdp = appendFmtp(offer.sdp);\n        }\n        console.log('offer ', offer, offer.sdp)\n      \n      normalizeSdpObject(offer);\n      \n      // Set up event handlers BEFORE setRemoteDescription to avoid missing events\n      peerConnection.onicecandidate = function (e) {\n\n            if (e.candidate && e.candidate.candidate) {\n\n                console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\n\n                sendMessage(instance.webSocket, {\n                    id: id,\n                    peer_id: peerId,\n                    command: 'candidate',\n                    candidates: [e.candidate]\n                });\n            }\n        };\n\n        peerConnection.oniceconnectionstatechange = function (e) {\n\n            let state = peerConnection.iceConnectionState;\n\n            if (instance.callbacks.iceStateChange) {\n\n                console.info(logHeader, 'ICE State', '[' + state + ']');\n                instance.callbacks.iceStateChange(state);\n            }\n\n            if (state === 'connected') {\n\n                if (instance.callbacks.connected) {\n\n                    console.info(logHeader, 'Iceconnection Connected', e);\n                    instance.callbacks.connected(e);\n                }\n            }\n\n            if (state === 'failed' || state === 'disconnected' || state === 'closed') {\n\n                if (instance.callbacks.connectionClosed) {\n\n                    console.error(logHeader, 'Iceconnection Closed', e);\n                    instance.callbacks.connectionClosed('ice', e);\n                }\n            }\n        };\n      \n      peerConnection.setRemoteDescription(offer)\n            .then(function () {\n\n                peerConnection.createAnswer()\n                    .then(function (answer) {\n\n                        if (checkIOSVersion() >= 15) {\n\n                            const formatNumber = getFormatNumber(answer.sdp, 'H264');\n\n                            if (formatNumber > 0) {\n\n                                answer.sdp = removeFormat(answer.sdp, formatNumber);\n                            }\n                        }\n\n                        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n\n                            answer.sdp = appendFmtp(answer.sdp);\n                        }\n                        console.log('answer ', answer, answer.sdp);\n\n                        peerConnection.setLocalDescription(answer)\n                            .then(function () {\n\n                                sendMessage(instance.webSocket, {\n                                    id: id,\n                                    peer_id: peerId,\n                                    command: 'answer',\n                                    sdp: answer\n                                });\n                            })\n                            .catch(function (error) {\n\n                                console.error('peerConnection.setLocalDescription', error);\n                                errorHandler(error);\n                            });\n                    })\n                    .catch(function (error) {\n\n                        console.error('peerConnection.createAnswer', error);\n                        errorHandler(error);\n                    });\n            })\n            .catch(function (error) {\n\n                console.error('peerConnection.setRemoteDescription', error);\n                errorHandler(error);\n            });\n\n        if (candidates) {\n\n            addIceCandidate(peerConnection, candidates);\n        }\n    }\n\n    function addIceCandidate(peerConnection, candidates) {\n        console.log('addIceCandidate', peerConnection, candidates);\n        for (let i = 0; i < candidates.length; i++) {\n\n            if (candidates[i] && candidates[i].candidate) {\n\n                let basicCandidate = candidates[i];\n\n                peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate))\n                    .then(function () {\n\n                    })\n                    .catch(function (error) {\n\n                        console.error('peerConnection.addIceCandidate', basicCandidate, error);\n                        errorHandler(error);\n                    });\n            }\n        }\n    }\n\n    // instance methods\n    instance.attachMedia = function (videoElement) {\n\n        instance.videoElement = videoElement;\n    };\n\n    instance.getUserMedia = function (constraints) {\n\n        return getUserMedia(constraints);\n    };\n\n    instance.getDisplayMedia = function (constraints) {\n\n        return getDisplayMedia(constraints);\n    };\n\n    instance.startStreaming = function (connectionUrl, connectionConfig) {\n\n        connectionUrl+=\"?direction=send&transport=tcp\"\n\n        console.info(logEventHeader, 'Start Streaming');\n\n        if (connectionConfig) {\n\n            instance.connectionConfig = connectionConfig;\n        }\n        \n        instance.retriesUsed = 0;\n        initWebSocket(connectionUrl);\n    };\n\n    instance.remove = function () {\n\n        instance.removing = true;\n\n        // first release peer connection with ome\n        if (instance.peerConnection) {\n\n            // remove tracks from peer connection\n            instance.peerConnection.getSenders().forEach(function (sender) {\n                instance.peerConnection.removeTrack(sender);\n            });\n\n            instance.peerConnection.close();\n            instance.peerConnection = null;\n            delete instance.peerConnection;\n        }\n\n        // release video, audio stream\n        if (instance.stream) {\n\n            instance.stream.getTracks().forEach(track => {\n\n                track.stop();\n                instance.stream.removeTrack(track);\n            });\n\n            if (instance.videoElement) {\n                instance.videoElement.srcObject = null;\n            }\n\n            instance.stream = null;\n            delete instance.stream;\n        }\n\n        // release websocket\n        if (instance.webSocket) {\n            \n            sendMessage(instance.webSocket, {\n                id: window.connectionData.id,\n                peer_id: window.connectionData.peerId,\n                command: 'stop',\n            });\n\n            instance.webSocket.close();\n            instance.webSocket = null;\n            delete instance.webSocket;\n        }\n\n        instance.status = 'removed';\n\n        console.info(logEventHeader, 'Removed');\n\n    };\n}\n\n// static methods\nQencodeWebRTC.create = function (options) {\n\n    console.info(logEventHeader, 'Create WebRTC');\n\n    let instance = {\n      retryMaxCount: 2,\n      retryDelay: 2000,\n    };\n\n    instance.removing = false;\n\n    initConfig(instance, options);\n    addMethod(instance);\n\n    return instance;\n};\n\nQencodeWebRTC.getDevices = async function () {\n\n    await getStreamForDeviceCheck();\n    const deviceInfos = await getDevices();\n    return gotDevices(deviceInfos)\n};\n\nexport default QencodeWebRTC;"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","sendMessage","webSocket","message","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","checkIOSVersion","agent","window","navigator","userAgent","start","indexOf","Number","substr","replace","splitSdpLines","sdp","split","map","line","joinSdpLines","lines","join","getFormatNumber","format","formatNumber","i","length","toLowerCase","removeFormat","newLines","push","create","options","console","info","instance","retryMaxCount","retryDelay","stream","peerConnection","connectionConfig","status","videoElement","connectionUrl","callbacks","initConfig","errorHandler","error","initWebSocket","WebSocket","onopen","command","onmessage","e","parse","data","id","peerId","offer","candidates","iceServers","connectionData","peerConnectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","j","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","getTracks","forEach","track","addTrack","maxVideoBitrate","media","bitrate","slice","concat","setBitrateLimit","appendFmtp","log","hasOwn","normalizeSdpObject","onicecandidate","candidate","peer_id","oniceconnectionstatechange","state","iceConnectionState","iceStateChange","connected","connectionClosed","setRemoteDescription","then","createAnswer","answer","setLocalDescription","catch","basicCandidate","addIceCandidate","RTCIceCandidate","createPeerConnection","ice_servers","onerror","async","fn","args","delay","retriesUsed","removing","retrying","isFinite","readyState","CLOSED","onclose","close","Promise","resolve","setTimeout","fmtpStr","payloads","tokens","fmtpLineFound","attachMedia","getUserMedia","constraints","video","deviceId","undefined","audio","mediaDevices","elem","srcObject","onloadedmetadata","play","reject","getDisplayMedia","startStreaming","remove","getSenders","sender","removeTrack","stop","addMethod","getDevices","width","height","getStreamForDeviceCheck","deviceInfos","devices","deviceInfo","kind","label","audioinput","audiooutput","videoinput","other","gotDevices","enumerateDevices"],"sourceRoot":""}