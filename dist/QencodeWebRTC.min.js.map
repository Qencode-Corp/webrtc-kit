{"version":3,"file":"QencodeWebRTC.min.js","mappings":"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","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const QencodeWebRTC = {};\r\n\r\nconst logHeader = 'QencodeWebRTC.js :';\r\nconst logEventHeader = 'QencodeWebRTC.js :';\r\n\r\n// private methods\r\nfunction sendMessage(webSocket, message) {\r\n\r\n    if (webSocket) {\r\n        webSocket.send(JSON.stringify(message));\r\n    }\r\n}\r\n\r\nfunction generateDomainFromUrl(url) {\r\n    let result = '';\r\n    let match;\r\n    if (match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im)) {\r\n        result = match[1];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction findIp(string) {\r\n\r\n    let result = '';\r\n    let match;\r\n\r\n    if (match = string.match(new RegExp('\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b', 'gi'))) {\r\n        result = match[0];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction checkIOSVersion() {\r\n    var agent = window.navigator.userAgent,\r\n        start = agent.indexOf('OS ');\r\n    if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\r\n        return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction getFormatNumber(sdp, format) {\r\n\r\n    const lines = sdp.split('\\n');\r\n    let formatNumber = -1;\r\n\r\n    for (let i = 0; i < lines.length - 1; i++) {\r\n\r\n        lines[i] = lines[i].toLowerCase();\r\n\r\n        if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\r\n            // parsing \"a=rtpmap:100 H264/90000\" line\r\n            formatNumber = lines[i].split(' ')[0].split(':')[1];\r\n            break;\r\n        }\r\n    }\r\n\r\n    return formatNumber;\r\n}\r\n\r\nfunction removeFormat(sdp, formatNumber) {\r\n    let newLines = [];\r\n    let lines = sdp.split('\\n');\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n\r\n        if (lines[i].indexOf('m=video') === 0) {\r\n            newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\r\n        } else if (lines[i].indexOf(formatNumber + '') > -1) {\r\n\r\n        } else {\r\n            newLines.push(lines[i]);\r\n        }\r\n    }\r\n\r\n    return newLines.join('\\n')\r\n}\r\n\r\nasync function getStreamForDeviceCheck() {\r\n\r\n    // High resolution video constraints makes browser to get maximum resolution of video device.\r\n    const constraints = {\r\n        audio: { deviceId: undefined },\r\n        video: { deviceId: undefined, width: 1920, height: 1080 }\r\n    };\r\n\r\n    return await navigator.mediaDevices.getUserMedia(constraints);\r\n}\r\n\r\nasync function getDevices() {\r\n\r\n    return await navigator.mediaDevices.enumerateDevices();\r\n\r\n\r\n}\r\n\r\nfunction gotDevices(deviceInfos) {\r\n\r\n    let devices = {\r\n        'audioinput': [],\r\n        'audiooutput': [],\r\n        'videoinput': [],\r\n        'other': [],\r\n    };\r\n\r\n    for (let i = 0; i !== deviceInfos.length; ++i) {\r\n\r\n        const deviceInfo = deviceInfos[i];\r\n\r\n        let info = {};\r\n\r\n        info.deviceId = deviceInfo.deviceId;\r\n\r\n        if (deviceInfo.kind === 'audioinput') {\r\n\r\n            info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\r\n            devices.audioinput.push(info);\r\n        } else if (deviceInfo.kind === 'audiooutput') {\r\n\r\n            info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\r\n            devices.audiooutput.push(info);\r\n        } else if (deviceInfo.kind === 'videoinput') {\r\n\r\n            info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\r\n            devices.videoinput.push(info);\r\n        } else {\r\n\r\n            info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\r\n            devices.other.push(info);\r\n        }\r\n    }\r\n\r\n    return devices;\r\n}\r\n\r\nfunction initConfig(instance, options) {\r\n\r\n    instance.stream = null;\r\n    instance.webSocket = null;\r\n    instance.peerConnection = null;\r\n    instance.connectionConfig = {};\r\n\r\n    instance.status = 'creating';\r\n\r\n    instance.videoElement = null;\r\n    instance.connectionUrl = null;\r\n\r\n    if (options && options.callbacks) {\r\n\r\n        instance.callbacks = options.callbacks;\r\n    } else {\r\n        instance.callbacks = {};\r\n    }\r\n\r\n}\r\n\r\nfunction addMethod(instance) {\r\n\r\n    instance.pendingRemoteCandidates = [];\r\n    instance.remoteDescriptionSet = false;\r\n\r\n    function errorHandler(error) {\r\n\r\n        if (instance.callbacks.error) {\r\n\r\n            instance.callbacks.error(error);\r\n        }\r\n    }\r\n\r\n    function getUserMedia(constraints) {\r\n\r\n        if (!constraints) {\r\n\r\n            constraints = {\r\n                video: {\r\n                    deviceId: undefined\r\n                },\r\n                audio: {\r\n                    deviceId: undefined\r\n                }\r\n            };\r\n        }\r\n\r\n        console.info(logHeader, 'Requested Constraint To Input Devices', constraints);\r\n\r\n        return navigator.mediaDevices.getUserMedia(constraints)\r\n            .then(function (stream) {\r\n\r\n                console.info(logHeader, 'Received Media Stream From Input Device', stream);\r\n\r\n                instance.stream = stream;\r\n\r\n                let elem = instance.videoElement;\r\n\r\n                // Attach stream to video element when video element is provided.\r\n                if (elem) {\r\n\r\n                    elem.srcObject = stream;\r\n\r\n                    elem.onloadedmetadata = function (e) {\r\n\r\n                        elem.play();\r\n                    };\r\n                }\r\n\r\n                return new Promise(function (resolve) {\r\n\r\n                    resolve(stream);\r\n                });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error(logHeader, 'Can\\'t Get Media Stream From Input Device', error);\r\n                errorHandler(error);\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    reject(error);\r\n                });\r\n            });\r\n    }\r\n\r\n    function getDisplayMedia(constraints) {\r\n\r\n        if (!constraints) {\r\n            constraints = {};\r\n        }\r\n\r\n        console.info(logHeader, 'Requested Constraint To Display', constraints);\r\n\r\n        return navigator.mediaDevices.getDisplayMedia(constraints)\r\n            .then(function (stream) {\r\n\r\n                console.info(logHeader, 'Received Media Stream From Display', stream);\r\n\r\n                instance.stream = stream;\r\n\r\n                let elem = instance.videoElement;\r\n\r\n                // Attach stream to video element when video element is provided.\r\n                if (elem) {\r\n\r\n                    elem.srcObject = stream;\r\n\r\n                    elem.onloadedmetadata = function (e) {\r\n\r\n                        elem.play();\r\n                    };\r\n                }\r\n\r\n                return new Promise(function (resolve) {\r\n\r\n                    resolve(stream);\r\n                });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error(logHeader, 'Can\\'t Get Media Stream From Display', error);\r\n                errorHandler(error);\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    reject(error);\r\n                });\r\n            });\r\n    }\r\n\r\n    // From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\r\n    function setBitrateLimit(sdp, media, bitrate) {\r\n\r\n        let lines = sdp.split('\\n');\r\n        let line = -1;\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (lines[i].indexOf('m=' + media) === 0) {\r\n                line = i;\r\n                break;\r\n            }\r\n        }\r\n        if (line === -1) {\r\n            // Could not find the m line for media\r\n            return sdp;\r\n        }\r\n\r\n        // Pass the m line\r\n        line++;\r\n\r\n        // Skip i and c lines\r\n        while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\r\n\r\n            line++;\r\n        }\r\n\r\n        // If we're on a b line, replace it\r\n        if (lines[line].indexOf('b') === 0) {\r\n\r\n            lines[line] = 'b=AS:' + bitrate;\r\n\r\n            return lines.join('\\n');\r\n        }\r\n\r\n        // Add a new b line\r\n        let newLines = lines.slice(0, line)\r\n\r\n        newLines.push('b=AS:' + bitrate)\r\n        newLines = newLines.concat(lines.slice(line, lines.length))\r\n\r\n        return newLines.join('\\n')\r\n    }\r\n\r\n    function initWebSocket(connectionUrl) {\r\n\r\n        if (!connectionUrl) {\r\n            errorHandler('connectionUrl is required');\r\n            return;\r\n        }\r\n\r\n        instance.connectionUrl = connectionUrl;\r\n\r\n        let webSocket = null;\r\n\r\n        try {\r\n\r\n            webSocket = new WebSocket(connectionUrl);\r\n        } catch (error) {\r\n\r\n            errorHandler(error);\r\n        }\r\n\r\n\r\n        instance.webSocket = webSocket;\r\n\r\n        webSocket.onopen = function () {\r\n\r\n            // Request offer at the first time.\r\n            sendMessage(webSocket, {\r\n                command: 'request_offer'\r\n            });\r\n        };\r\n\r\n        webSocket.onmessage = function (e) {\r\n\r\n            let message = JSON.parse(e.data);\r\n\r\n            if (message.error) {\r\n                console.error('webSocket.onmessage', message.error);\r\n                errorHandler(message.error);\r\n            }\r\n\r\n            if (message.command === 'offer') {\r\n\r\n                instance.pendingRemoteCandidates = [];\r\n                instance.remoteDescriptionSet = false;            \r\n\r\n                // OME returns offer. Start create peer connection.\r\n                createPeerConnection(\r\n                    message.id,\r\n                    message.peer_id,\r\n                    message.sdp,\r\n                    message.candidates,\r\n                    message.ice_servers\r\n                );\r\n            }\r\n\r\n            // // ✅ New: accept remote trickle candidates\r\n            // if (message.command === 'candidate' && instance.peerConnection && message.candidates?.length) {\r\n            //     addIceCandidate(instance.peerConnection, message.candidates);\r\n            //     return;\r\n            // }   \r\n            \r\n            // ✅ Accept remote trickle candidates with a small queue\r\n            if (message.command === 'candidate' && message.candidates?.length) {\r\n                if (!instance.peerConnection || !instance.remoteDescriptionSet) {\r\n                    instance.pendingRemoteCandidates.push(...message.candidates);\r\n                } else {\r\n                    addIceCandidate(instance.peerConnection, message.candidates);\r\n                }\r\n                return;\r\n            }         \r\n        };\r\n\r\n        webSocket.onerror = function (error) {\r\n\r\n            console.error('webSocket.onerror', error);\r\n            errorHandler(error);\r\n        };\r\n\r\n        webSocket.onclose = function (e) {\r\n\r\n            if (!instance.removing) {\r\n\r\n                if (instance.callbacks.connectionClosed) {\r\n\r\n                    instance.callbacks.connectionClosed('websocket', e);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n\r\n    function appendFmtp(sdp) {\r\n\r\n        const fmtpStr = instance.connectionConfig.sdp.appendFmtp;\r\n\r\n        const lines = sdp.split('\\n');\r\n        const payloads = [];\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n\r\n            if (lines[i].indexOf('m=video') === 0) {\r\n\r\n                let tokens = lines[i].split(' ')\r\n\r\n                for (let j = 3; j < tokens.length; j++) {\r\n\r\n                    payloads.push(tokens[j].replace('\\r', ''));\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < payloads.length; i++) {\r\n\r\n            let fmtpLineFound = false;\r\n\r\n            for (let j = 0; j < lines.length; j++) {\r\n\r\n                if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\r\n                    fmtpLineFound = true;\r\n                    lines[j] += ';' + fmtpStr;\r\n                }\r\n            }\r\n\r\n            if (!fmtpLineFound) {\r\n\r\n                for (let j = 0; j < lines.length; j++) {\r\n\r\n                    if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\r\n\r\n                        lines[j] += '\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lines.join('\\n')\r\n    }\r\n\r\n    function createPeerConnection(id, peerId, offer, candidates, iceServers) {\r\n\r\n        window.connectionData = {\r\n            id,\r\n            peerId\r\n        }\r\n\r\n        let peerConnectionConfig = {};\r\n\r\n        if (instance.connectionConfig.iceServers) {\r\n\r\n            // first priority using ice servers from local config.\r\n            peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\r\n\r\n            if (instance.connectionConfig.iceTransportPolicy) {\r\n\r\n                // peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\r\n\r\n                // Instead of always forcing relay:\r\n                peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy || 'all';\r\n\r\n            }\r\n        } else if (iceServers) {\r\n\r\n            // second priority using ice servers from ome and force using TCP\r\n            peerConnectionConfig.iceServers = [];\r\n\r\n            for (let i = 0; i < iceServers.length; i++) {\r\n\r\n                let iceServer = iceServers[i];\r\n\r\n                let regIceServer = {};\r\n\r\n                regIceServer.urls = iceServer.urls;\r\n\r\n                let hasWebSocketUrl = false;\r\n                let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\r\n\r\n                for (let j = 0; j < regIceServer.urls.length; j++) {\r\n\r\n                    let serverUrl = regIceServer.urls[j];\r\n\r\n                    if (serverUrl.indexOf(webSocketUrl) > -1) {\r\n                        hasWebSocketUrl = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!hasWebSocketUrl) {\r\n\r\n                    if (regIceServer.urls.length > 0) {\r\n\r\n                        let cloneIceServer = regIceServer.urls[0];\r\n                        let ip = findIp(cloneIceServer);\r\n\r\n                        if (webSocketUrl && ip) {\r\n                            regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                regIceServer.username = iceServer.user_name;\r\n                regIceServer.credential = iceServer.credential;\r\n\r\n                peerConnectionConfig.iceServers.push(regIceServer);\r\n            }\r\n\r\n            peerConnectionConfig.iceTransportPolicy = 'relay';\r\n        } else {\r\n            // last priority using default ice servers.\r\n\r\n            if (instance.iceTransportPolicy) {\r\n\r\n                peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\r\n            }\r\n        }\r\n\r\n        let advancedSetting = {\r\n            optional: [\r\n                {\r\n                    googHighStartBitrate: {\r\n                        exact: !0\r\n                    }\r\n                },\r\n                {\r\n                    googPayloadPadding: {\r\n                        exact: !0\r\n                    }\r\n                },\r\n                {\r\n                    googScreencastMinBitrate: {\r\n                        exact: 500\r\n                    }\r\n                },\r\n                {\r\n                    enableDscp: {\r\n                        exact: true\r\n                    }\r\n                }\r\n            ]\r\n        };\r\n\r\n        console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\r\n\r\n        let peerConnection = new RTCPeerConnection(peerConnectionConfig);\r\n\r\n        instance.peerConnection = peerConnection;\r\n\r\n        // set local stream\r\n        instance.stream.getTracks().forEach(function (track) {\r\n\r\n            console.info(logHeader, 'Add Track To Peer Connection', track);\r\n            peerConnection.addTrack(track, instance.stream);\r\n        });\r\n\r\n\r\n        // if (checkIOSVersion() >= 15) {\r\n        //     const formatNumber = getFormatNumber(offer.sdp, 'H264');\r\n\r\n        //     if (formatNumber > 0) {\r\n        //         offer.sdp = removeFormat(offer.sdp, formatNumber);\r\n        //     }\r\n        // }\r\n\r\n        if (instance.connectionConfig.maxVideoBitrate) {\r\n\r\n            // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\r\n            offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\r\n        }\r\n\r\n        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\r\n\r\n            offer.sdp = appendFmtp(offer.sdp);\r\n        }\r\n\r\n        peerConnection.setRemoteDescription(new RTCSessionDescription(offer))\r\n            .then(function () {\r\n\r\n                instance.remoteDescriptionSet = true;\r\n                if (instance.pendingRemoteCandidates.length) {\r\n                    addIceCandidate(instance.peerConnection, instance.pendingRemoteCandidates);\r\n                    instance.pendingRemoteCandidates = [];\r\n                }\r\n\r\n                peerConnection.createAnswer()\r\n                    .then(function (answer) {\r\n\r\n                        // if (checkIOSVersion() >= 15) {\r\n\r\n                        //     const formatNumber = getFormatNumber(answer.sdp, 'H264');\r\n\r\n                        //     if (formatNumber > 0) {\r\n\r\n                        //         answer.sdp = removeFormat(answer.sdp, formatNumber);\r\n                        //     }\r\n                        // }\r\n\r\n                        if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\r\n\r\n                            answer.sdp = appendFmtp(answer.sdp);\r\n                        }\r\n\r\n                        peerConnection.setLocalDescription(answer)\r\n                            .then(function () {\r\n\r\n                                sendMessage(instance.webSocket, {\r\n                                    id: id,\r\n                                    peer_id: peerId,\r\n                                    command: 'answer',\r\n                                    sdp: answer\r\n                                });\r\n                            })\r\n                            .catch(function (error) {\r\n\r\n                                console.error('peerConnection.setLocalDescription', error);\r\n                                errorHandler(error);\r\n                            });\r\n                    })\r\n                    .catch(function (error) {\r\n\r\n                        console.error('peerConnection.createAnswer', error);\r\n                        errorHandler(error);\r\n                    });\r\n            })\r\n            .catch(function (error) {\r\n\r\n                console.error('peerConnection.setRemoteDescription', error);\r\n                errorHandler(error);\r\n            });\r\n\r\n        if (candidates) {\r\n\r\n            addIceCandidate(peerConnection, candidates);\r\n        }\r\n\r\n        peerConnection.onicecandidate = function (e) {\r\n\r\n            if (e.candidate && e.candidate.candidate) {\r\n\r\n                console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\r\n\r\n                sendMessage(instance.webSocket, {\r\n                    id: id,\r\n                    peer_id: peerId,\r\n                    command: 'candidate',\r\n                    candidates: [e.candidate]\r\n                });\r\n            }\r\n        };\r\n\r\n        peerConnection.oniceconnectionstatechange = function (e) {\r\n\r\n            let state = peerConnection.iceConnectionState;\r\n\r\n            if (instance.callbacks.iceStateChange) {\r\n\r\n                console.info(logHeader, 'ICE State', '[' + state + ']');\r\n                instance.callbacks.iceStateChange(state);\r\n            }\r\n\r\n            if (state === 'connected') {\r\n\r\n                if (instance.callbacks.connected) {\r\n\r\n                    console.info(logHeader, 'Iceconnection Connected', e);\r\n                    instance.callbacks.connected(e);\r\n                }\r\n            }\r\n\r\n            if (state === 'failed' || state === 'disconnected' || state === 'closed') {\r\n\r\n                if (instance.callbacks.connectionClosed) {\r\n\r\n                    console.error(logHeader, 'Iceconnection Closed', e);\r\n                    instance.callbacks.connectionClosed('ice', e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIceCandidate(peerConnection, candidates) {\r\n\r\n        for (let i = 0; i < candidates.length; i++) {\r\n\r\n            if (candidates[i] && candidates[i].candidate) {\r\n\r\n                let basicCandidate = candidates[i];\r\n\r\n                peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate))\r\n                    .then(function () {\r\n\r\n                    })\r\n                    .catch(function (error) {\r\n\r\n                        console.error('peerConnection.addIceCandidate', error);\r\n                        errorHandler(error);\r\n                    });\r\n            }\r\n        }\r\n    }\r\n\r\n    // instance methods\r\n    instance.attachMedia = function (videoElement) {\r\n\r\n        instance.videoElement = videoElement;\r\n    };\r\n\r\n    instance.getUserMedia = function (constraints) {\r\n\r\n        return getUserMedia(constraints);\r\n    };\r\n\r\n    instance.getDisplayMedia = function (constraints) {\r\n\r\n        return getDisplayMedia(constraints);\r\n    };\r\n\r\n    instance.startStreaming = function (connectionUrl, connectionConfig) {\r\n\r\n        connectionUrl+=\"?direction=send&transport=tcp\"\r\n\r\n        console.info(logEventHeader, 'Start Streaming');\r\n\r\n        if (connectionConfig) {\r\n\r\n            instance.connectionConfig = connectionConfig;\r\n        }\r\n\r\n        initWebSocket(connectionUrl);\r\n    };\r\n\r\n    instance.remove = function () {\r\n\r\n        instance.removing = true;\r\n\r\n        // first release peer connection with ome\r\n        if (instance.peerConnection) {\r\n\r\n            // remove tracks from peer connection\r\n            instance.peerConnection.getSenders().forEach(function (sender) {\r\n                instance.peerConnection.removeTrack(sender);\r\n            });\r\n\r\n            instance.peerConnection.close();\r\n            instance.peerConnection = null;\r\n            delete instance.peerConnection;\r\n        }\r\n\r\n        // release video, audio stream\r\n        if (instance.stream) {\r\n\r\n            instance.stream.getTracks().forEach(track => {\r\n\r\n                track.stop();\r\n                instance.stream.removeTrack(track);\r\n            });\r\n\r\n            if (instance.videoElement) {\r\n                instance.videoElement.srcObject = null;\r\n            }\r\n\r\n            instance.stream = null;\r\n            delete instance.stream;\r\n        }\r\n\r\n        // release websocket\r\n        if (instance.webSocket) {\r\n            \r\n            sendMessage(instance.webSocket, {\r\n                id: window.connectionData.id,\r\n                peer_id: window.connectionData.peerId,\r\n                command: 'stop',\r\n            });\r\n\r\n            instance.webSocket.close();\r\n            instance.webSocket = null;\r\n            delete instance.webSocket;\r\n        }\r\n\r\n        instance.status = 'removed';\r\n\r\n        console.info(logEventHeader, 'Removed');\r\n\r\n    };\r\n}\r\n\r\n// static methods\r\nQencodeWebRTC.create = function (options) {\r\n\r\n    console.info(logEventHeader, 'Create WebRTC');\r\n\r\n    let instance = {};\r\n\r\n    instance.removing = false;\r\n\r\n    initConfig(instance, options);\r\n    addMethod(instance);\r\n\r\n    return instance;\r\n};\r\n\r\nQencodeWebRTC.getDevices = async function () {\r\n\r\n    await getStreamForDeviceCheck();\r\n    const deviceInfos = await getDevices();\r\n    return gotDevices(deviceInfos)\r\n};\r\n\r\nexport default QencodeWebRTC;"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","sendMessage","webSocket","message","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","addMethod","instance","errorHandler","error","callbacks","appendFmtp","sdp","fmtpStr","connectionConfig","lines","split","payloads","i","length","indexOf","tokens","j","push","replace","fmtpLineFound","join","addIceCandidate","peerConnection","candidates","candidate","basicCandidate","RTCIceCandidate","then","catch","console","pendingRemoteCandidates","remoteDescriptionSet","attachMedia","videoElement","getUserMedia","constraints","video","deviceId","undefined","audio","info","navigator","mediaDevices","stream","elem","srcObject","onloadedmetadata","e","play","Promise","resolve","reject","getDisplayMedia","startStreaming","connectionUrl","WebSocket","onopen","command","onmessage","parse","data","id","peerId","offer","iceServers","window","connectionData","peerConnectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","getTracks","forEach","track","addTrack","maxVideoBitrate","media","bitrate","line","newLines","slice","concat","setBitrateLimit","setRemoteDescription","RTCSessionDescription","createAnswer","answer","setLocalDescription","peer_id","onicecandidate","oniceconnectionstatechange","state","iceConnectionState","iceStateChange","connected","connectionClosed","createPeerConnection","ice_servers","onerror","onclose","removing","initWebSocket","remove","getSenders","sender","removeTrack","close","stop","status","create","options","initConfig","getDevices","async","width","height","getStreamForDeviceCheck","deviceInfos","devices","deviceInfo","kind","label","audioinput","audiooutput","videoinput","other","gotDevices","enumerateDevices"],"sourceRoot":""}