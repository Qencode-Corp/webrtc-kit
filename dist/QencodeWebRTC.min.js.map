{"version":3,"file":"QencodeWebRTC.min.js","mappings":"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","sources":["webpack://QencodeWebRTC/webpack/universalModuleDefinition","webpack://QencodeWebRTC/webpack/bootstrap","webpack://QencodeWebRTC/webpack/runtime/define property getters","webpack://QencodeWebRTC/webpack/runtime/hasOwnProperty shorthand","webpack://QencodeWebRTC/./src/QencodeWebRTC.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QencodeWebRTC\"] = factory();\n\telse\n\t\troot[\"QencodeWebRTC\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const QencodeWebRTC = {};\n\nconst logHeader = 'QencodeWebRTC.js :';\nconst logEventHeader = 'QencodeWebRTC.js :';\n\n// private methods\nfunction sendMessage(webSocket, message) {\n  if (webSocket && webSocket.readyState === WebSocket.OPEN) {\n    webSocket.send(JSON.stringify(message));\n  }\n}\n\nfunction generateDomainFromUrl(url) {\n  let result = '';\n  let match;\n  if ((match = url.match(/^(?:wss?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n\\?\\=]+)/im))) {\n    result = match[1];\n  }\n\n  return result;\n}\n\nfunction findIp(string) {\n  let result = '';\n  let match;\n\n  if (\n    (match = string.match(\n      new RegExp(\n        '\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b',\n        'gi'\n      )\n    ))\n  ) {\n    result = match[0];\n  }\n\n  return result;\n}\n\nfunction checkIOSVersion() {\n  var agent = window.navigator.userAgent,\n    start = agent.indexOf('OS ');\n  if ((agent.indexOf('iPhone') > -1 || agent.indexOf('iPad') > -1) && start > -1) {\n    return window.Number(agent.substr(start + 3, 3).replace('_', '.'));\n  }\n  return 0;\n}\n\n// SDP helper functions to properly handle CRLF line endings (RFC 4566)\nfunction splitSdpLines(sdp) {\n  // Normalize line endings: split on \\r\\n or \\n, and remove trailing \\r from each line\n  return sdp.split(/\\r?\\n/).map((line) => line.replace(/\\r$/, ''));\n}\n\nfunction joinSdpLines(lines) {\n  // Join with CRLF as required by SDP specification (RFC 4566)\n  return lines.join('\\r\\n');\n}\n\nfunction getFormatNumber(sdp, format) {\n  const lines = splitSdpLines(sdp);\n  let formatNumber = -1;\n\n  for (let i = 0; i < lines.length - 1; i++) {\n    lines[i] = lines[i].toLowerCase();\n\n    if (lines[i].indexOf('a=rtpmap') > -1 && lines[i].indexOf(format.toLowerCase()) > -1) {\n      // parsing \"a=rtpmap:100 H264/90000\" line\n      formatNumber = lines[i].split(' ')[0].split(':')[1];\n      break;\n    }\n  }\n\n  return formatNumber;\n}\n\nfunction removeFormat(sdp, formatNumber) {\n  let newLines = [];\n  let lines = splitSdpLines(sdp);\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=video') === 0) {\n      newLines.push(lines[i].replace(' ' + formatNumber + '', ''));\n    } else if (lines[i].indexOf(formatNumber + '') > -1) {\n    } else {\n      newLines.push(lines[i]);\n    }\n  }\n\n  return joinSdpLines(newLines);\n}\n\nasync function getStreamForDeviceCheck() {\n  // High resolution video constraints makes browser to get maximum resolution of video device.\n  // Using 'ideal' instead of exact values for better compatibility with different cameras.\n  const constraints = {\n    audio: { deviceId: undefined },\n    video: { deviceId: undefined, width: { ideal: 1920 }, height: { ideal: 1080 } },\n  };\n\n  return await navigator.mediaDevices.getUserMedia(constraints);\n}\n\nasync function getDevices() {\n  return await navigator.mediaDevices.enumerateDevices();\n}\n\nfunction gotDevices(deviceInfos) {\n  let devices = {\n    audioinput: [],\n    audiooutput: [],\n    videoinput: [],\n    other: [],\n  };\n\n  for (let i = 0; i !== deviceInfos.length; ++i) {\n    const deviceInfo = deviceInfos[i];\n\n    let info = {};\n\n    info.deviceId = deviceInfo.deviceId;\n\n    if (deviceInfo.kind === 'audioinput') {\n      info.label = deviceInfo.label || `microphone ${devices.audioinput.length + 1}`;\n      devices.audioinput.push(info);\n    } else if (deviceInfo.kind === 'audiooutput') {\n      info.label = deviceInfo.label || `speaker ${devices.audiooutput.length + 1}`;\n      devices.audiooutput.push(info);\n    } else if (deviceInfo.kind === 'videoinput') {\n      info.label = deviceInfo.label || `camera ${devices.videoinput.length + 1}`;\n      devices.videoinput.push(info);\n    } else {\n      info.label = deviceInfo.label || `other ${devices.other.length + 1}`;\n      devices.other.push(info);\n    }\n  }\n\n  return devices;\n}\n\nfunction initConfig(config) {\n  let instance = {\n    retryMaxCount: 2,\n    retryDelay: 2000,\n    connectionConfig: {},\n    connectionUrl: null,\n    connectStarted: false,\n    error: null,\n    offerRequestCount: 0,\n    peerConnection: null,\n    retriesUsed: 0,\n    stream: null,\n    videoElement: null,\n    webSocket: null,\n    webSocketCloseEvent: null,\n    isManualStop: false,\n  };\n\n  if (config && config.callbacks) {\n    instance.callbacks = config.callbacks;\n  } else {\n    instance.callbacks = {};\n  }\n\n  return instance;\n}\n\nfunction waitForOnline() {\n  if (navigator.onLine) {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve) => {\n    console.log('Offline. Waiting for connection...');\n    // Use { once: true } to auto-remove the listener after it fires\n    window.addEventListener(\n      'online',\n      () => {\n        console.log('Back online!');\n        resolve();\n      },\n      { once: true }\n    );\n  });\n}\n\nfunction delayedCall(fn, args, delay) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      Promise.resolve(fn(...args)).then(resolve);\n    }, delay);\n  });\n}\n\n// From https://webrtchacks.com/limit-webrtc-bandwidth-sdp/\nfunction setBitrateLimit(sdp, media, bitrate) {\n  let lines = splitSdpLines(sdp);\n  let line = -1;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=' + media) === 0) {\n      line = i;\n      break;\n    }\n  }\n  if (line === -1) {\n    // Could not find the m line for media\n    return sdp;\n  }\n\n  // Pass the m line\n  line++;\n\n  // Skip i and c lines\n  while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\n    line++;\n  }\n\n  // If we're on a b line, replace it\n  if (lines[line].indexOf('b') === 0) {\n    lines[line] = 'b=AS:' + bitrate;\n\n    return joinSdpLines(lines);\n  }\n\n  // Add a new b line\n  let newLines = lines.slice(0, line);\n\n  newLines.push('b=AS:' + bitrate);\n  newLines = newLines.concat(lines.slice(line, lines.length));\n\n  return joinSdpLines(newLines);\n}\n\nfunction appendFmtp(fmtpStr, sdp) {\n  const lines = splitSdpLines(sdp);\n  const payloads = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf('m=video') === 0) {\n      let tokens = lines[i].split(' ');\n\n      for (let j = 3; j < tokens.length; j++) {\n        payloads.push(tokens[j]);\n      }\n\n      break;\n    }\n  }\n\n  for (let i = 0; i < payloads.length; i++) {\n    let fmtpLineFound = false;\n\n    for (let j = 0; j < lines.length; j++) {\n      if (lines[j].indexOf('a=fmtp:' + payloads[i]) === 0) {\n        fmtpLineFound = true;\n        lines[j] += ';' + fmtpStr;\n      }\n    }\n\n    if (!fmtpLineFound) {\n      for (let j = 0; j < lines.length; j++) {\n        if (lines[j].indexOf('a=rtpmap:' + payloads[i]) === 0) {\n          lines[j] += '\\r\\na=fmtp:' + payloads[i] + ' ' + fmtpStr;\n        }\n      }\n    }\n  }\n\n  return joinSdpLines(lines);\n}\n\nfunction addMethod(instance) {\n  function errorHandler(error) {\n    instance.error = error;\n    if (typeof instance.callbacks?.error === 'function') {\n      try {\n        instance.callbacks.error(error);\n      } catch (callbackError) {\n        console.error(logHeader, 'Error in error callback', callbackError);\n      }\n    }\n  }\n  \n  async function replaceTracksInPeerConnection(newStream) {\n    if (!instance.peerConnection || !newStream) {\n      return;\n    }\n    \n    const senders = instance.peerConnection.getSenders();\n    const newTracks = newStream.getTracks();\n    \n    // Map track kinds to their new tracks\n    const newVideoTrack = newTracks.find((track) => track.kind === 'video');\n    const newAudioTrack = newTracks.find((track) => track.kind === 'audio');\n    \n    // Replace tracks in existing senders\n    for (const sender of senders) {\n      if (!sender.track) continue; // Skip senders that are already empty\n      \n      if (sender.track.kind === 'video' && newVideoTrack) {\n        try {\n          // Replace the video track seamlessly\n          await sender.replaceTrack(newVideoTrack);\n          console.info(logHeader, 'Replaced video track in peer connection');\n        } catch (error) {\n          console.error(logHeader, 'Error replacing video track', error);\n          errorHandler(error);\n        }\n      } else if (sender.track.kind === 'audio' && newAudioTrack) {\n        try {\n          // Replace the audio track seamlessly\n          await sender.replaceTrack(newAudioTrack);\n          console.info(logHeader, 'Replaced audio track in peer connection');\n        } catch (error) {\n          console.error(logHeader, 'Error replacing audio track', error);\n          errorHandler(error);\n        }\n      }\n    }\n    \n    // Note: If you need to support adding new tracks (e.g. Audio -> Audio+Video),\n    // you must implement SDP renegotiation here. sender.replaceTrack only works\n    // if a sender for that media type already exists.\n  }\n  \n  function getUserMedia(constraints) {\n    if (!constraints) {\n      constraints = {\n        video: {\n          deviceId: undefined,\n        },\n        audio: {\n          deviceId: undefined,\n        },\n      };\n    }\n    \n    return navigator.mediaDevices\n      .getUserMedia(constraints)\n      .then(async function (stream) {\n        console.info(logHeader, 'Received Media Stream From Input Device', stream);\n        \n        // Check for active connection\n        const hasActiveConnection =\n          instance.peerConnection &&\n          !['closed', 'failed'].includes(instance.peerConnection.connectionState) &&\n          !['closed', 'failed'].includes(instance.peerConnection.iceConnectionState);\n        \n        // Capture the OLD stream before we update the instance variable\n        const oldStream = instance.stream;\n        \n        if (hasActiveConnection && oldStream) {\n          // 1. IMPORTANT: Replace tracks FIRST while old tracks are still active\n          await replaceTracksInPeerConnection(stream);\n          \n          // 2. Stop old tracks AFTER the replacement is done\n          // This prevents black frames or \"stream ended\" signals during switch\n          const oldTracks = oldStream.getTracks();\n          oldTracks.forEach((track) => {\n            track.stop();\n          });\n        }\n        \n        // Update instance stream to the new one\n        instance.stream = stream;\n        let elem = instance.videoElement;\n        \n        // Attach stream to video element when video element is provided.\n        if (elem) {\n          elem.srcObject = stream;\n          elem.onloadedmetadata = function (e) {\n            elem.play();\n          };\n        }\n        \n        return stream;\n      })\n      .catch(function (error) {\n        console.error(logHeader, \"Can't Get Media Stream From Input Device\", error);\n        errorHandler(error);\n        // Ensure the promise rejects so the caller knows it failed\n        throw error;\n      });\n  }\n  \n  function getDisplayMedia(constraints) {\n    if (!constraints) {\n      constraints = {};\n    }\n    \n    return navigator.mediaDevices\n      .getDisplayMedia(constraints)\n      .then(async function (stream) {\n        console.info(logHeader, 'Received Media Stream From Display', stream);\n        \n        const hasActiveConnection =\n          instance.peerConnection &&\n          !['closed', 'failed'].includes(instance.peerConnection.connectionState) &&\n          !['closed', 'failed'].includes(instance.peerConnection.iceConnectionState);\n        \n        const oldStream = instance.stream;\n        \n        if (hasActiveConnection && oldStream) {\n          // 1. Replace tracks first\n          await replaceTracksInPeerConnection(stream);\n          \n          // 2. Stop old tracks after\n          const oldTracks = oldStream.getTracks();\n          oldTracks.forEach((track) => {\n            track.stop();\n          });\n        }\n        \n        instance.stream = stream;\n        let elem = instance.videoElement;\n        \n        if (elem) {\n          elem.srcObject = stream;\n          elem.onloadedmetadata = function (e) {\n            elem.play();\n          };\n        }\n        \n        return stream;\n      })\n      .catch(function (error) {\n        console.error(logHeader, \"Can't Get Media Stream From Display\", error);\n        errorHandler(error);\n        throw error;\n      });\n  }\n\n  function requestOffer() {\n    sendMessage(instance.webSocket, {\n      command: 'request_offer',\n    });\n    instance.offerRequestCount += 1;\n  }\n\n  async function addRetryToQueue(delay) {\n    if (instance.isManualStop) return;\n\n    if (instance.reconnectWebSocketPromise) {\n      // Just hitch a ride on the existing attempt and exit.\n      await instance.reconnectWebSocketPromise;\n      return;\n    }\n\n    const retryDelay = delay ?? instance.retryDelay;\n\n    instance.reconnectWebSocketPromise = (async () => {\n      try {\n        await delayedCall(reconnectWebSocket, [], retryDelay);\n      } finally {\n        instance.reconnectWebSocketPromise = null;\n      }\n    })();\n\n    await instance.reconnectWebSocketPromise;\n  }\n\n  async function reconnectWebSocket() {\n    await waitForOnline();\n    instance.connectStarted = true;\n\n    // [FIX] Abort if user stopped stream while we were waiting for internet\n    if (instance.isManualStop) return;\n\n    const promise = new Promise(async function (resolve) {\n      let disconnected = true;\n      if (instance.peerConnection) {\n        if (\n          !['failed', 'disconnected', 'closed'].includes(instance.peerConnection.iceConnectionState)\n        ) {\n          disconnected = false;\n        }\n      }\n      if (\n        Number.isFinite(instance.retryDelay) &&\n        Number.isFinite(instance.retryMaxCount) &&\n        instance.retriesUsed < instance.retryMaxCount &&\n        disconnected\n      ) {\n        instance.isManualStop = false;\n        instance.retriesUsed += 1;\n        console.info(`online=${navigator.onLine}. Starting retry attempt ${instance.retriesUsed}`);\n\n        instance.closePeerConnection();\n        instance.closeWebSocket();\n\n        instance.error = null;\n        instance.webSocketCloseEvent = null;\n\n        try {\n          await delayedCall(initWebSocket, [], instance.retryDelay);\n        } catch (e) {\n        } finally {\n          instance.connectStarted = false;\n          resolve();\n        }\n      }\n      resolve();\n    });\n\n    return promise;\n  }\n\n  function initWebSocket() {\n    if (!instance.connectionUrl) {\n      errorHandler('connectionUrl is required');\n      return;\n    }\n\n    let webSocket = null;\n    try {\n      webSocket = new WebSocket(instance.connectionUrl);\n    } catch (error) {\n      errorHandler(error);\n      return;\n    }\n\n    instance.webSocket = webSocket;\n\n    webSocket.onopen = function () {\n      instance.retriesUsed = 0;\n      instance.offerRequestCount = 0;\n      requestOffer();\n    };\n\n    webSocket.onmessage = async function (e) {\n      let message = JSON.parse(e.data);\n\n      if (message.error) {\n        console.error('webSocket.onmessage', message.error);\n        await addRetryToQueue();\n        return;\n      }\n\n      if (message.command === 'offer') {\n        // OME returns offer. Start create peer connection.\n        try {\n          await createPeerConnection(\n            message.id,\n            message.peer_id,\n            message.sdp,\n            message.candidates,\n            message.ice_servers\n          );\n\n          instance.offerRequestCount = 0;\n          instance.connectStarted = false;\n        } catch (e) {\n          instance.connectStarted = false;\n          console.log('createPeerConnection error', e);\n\n          if (instance.offerRequestCount < 3) {\n            requestOffer();\n          } else {\n            await addRetryToQueue();\n          }\n        }\n      }\n    };\n\n    /* For reliability it is recommended to check for error with event code in onclose instead. */\n    webSocket.onerror = (e) => console.log('webSocket.onerror', e);\n\n    webSocket.onclose = async function (event) {\n      console.log('Connection closed', event);\n      instance.webSocketCloseEvent = event;\n      // Check if the close was clean (1000) or caused by an issue\n      if (event.code !== 1000) {\n        await addRetryToQueue();\n      } else {\n        console.log('Connection closed normally.');\n      }\n      instance.connectStarted = false;\n      if (!instance.isManualStop && instance.callbacks.connectionClosed) {\n        try {\n          instance.callbacks.connectionClosed('websocket', event);\n        } catch (callbackError) {\n          console.error(logHeader, 'Error in connectionClosed callback', callbackError);\n        }\n      }\n    };\n  }\n\n  function initRetryAfterLongEnoughIceDisconnect(timeout = 3000) {\n    if (!instance.iceDisconnectTimeoutId) {\n      instance.iceDisconnectTimeoutId = setTimeout(function () {\n        if (instance.isManualStop) return;\n\n        if (\n          instance.peerConnection &&\n          ['failed', 'disconnected'].includes(instance.peerConnection.iceConnectionState)\n        ) {\n          addRetryToQueue(0);\n        }\n      }, timeout);\n    }\n  }\n\n  function cancelRetryAfterLongEnoughIceDisconnect() {\n    clearTimeout(instance.iceDisconnectTimeoutId);\n    instance.iceDisconnectTimeoutId = null;\n  }\n\n  async function createPeerConnection(id, peerId, offer, candidates, iceServers) {\n    instance.connectionData = {\n      id,\n      peerId,\n    };\n\n    let peerConnectionConfig = {};\n\n    if (instance.connectionConfig.iceServers) {\n      // first priority using ice servers from local config.\n      peerConnectionConfig.iceServers = instance.connectionConfig.iceServers;\n\n      if (instance.connectionConfig.iceTransportPolicy) {\n        peerConnectionConfig.iceTransportPolicy = instance.connectionConfig.iceTransportPolicy;\n      }\n    } else if (iceServers) {\n      // second priority using ice servers from ome and force using TCP\n      peerConnectionConfig.iceServers = [];\n\n      for (let i = 0; i < iceServers.length; i++) {\n        let iceServer = iceServers[i];\n        let regIceServer = {};\n        regIceServer.urls = iceServer.urls;\n        let hasWebSocketUrl = false;\n        let webSocketUrl = generateDomainFromUrl(instance.connectionUrl);\n\n        for (let j = 0; j < regIceServer.urls.length; j++) {\n          let serverUrl = regIceServer.urls[j];\n\n          if (serverUrl.indexOf(webSocketUrl) > -1) {\n            hasWebSocketUrl = true;\n            break;\n          }\n        }\n\n        if (!hasWebSocketUrl) {\n          if (regIceServer.urls.length > 0) {\n            let cloneIceServer = regIceServer.urls[0];\n            let ip = findIp(cloneIceServer);\n\n            if (webSocketUrl && ip) {\n              regIceServer.urls.push(cloneIceServer.replace(ip, webSocketUrl));\n            }\n          }\n        }\n\n        regIceServer.username = iceServer.user_name;\n        regIceServer.credential = iceServer.credential;\n        peerConnectionConfig.iceServers.push(regIceServer);\n      }\n\n      peerConnectionConfig.iceTransportPolicy = 'relay';\n    } else {\n      // last priority using default ice servers.\n      if (instance.iceTransportPolicy) {\n        peerConnectionConfig.iceTransportPolicy = instance.iceTransportPolicy;\n      }\n    }\n\n    console.info(logHeader, 'Create Peer Connection With Config', peerConnectionConfig);\n\n    let peerConnection = new RTCPeerConnection(peerConnectionConfig);\n    instance.peerConnection = peerConnection;\n\n    // set local stream\n    instance.stream.getTracks().forEach(function (track) {\n      console.info(logHeader, 'Add Track To Peer Connection', track);\n      peerConnection.addTrack(track, instance.stream);\n    });\n\n    if (checkIOSVersion() >= 15) {\n      const formatNumber = getFormatNumber(offer.sdp, 'H264');\n\n      if (formatNumber > 0) {\n        offer.sdp = removeFormat(offer.sdp, formatNumber);\n      }\n    }\n\n    if (instance.connectionConfig.maxVideoBitrate) {\n      // if bandwith limit is set. modify sdp from ome to limit acceptable bandwidth of ome\n      offer.sdp = setBitrateLimit(offer.sdp, 'video', instance.connectionConfig.maxVideoBitrate);\n    }\n\n    if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n      offer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, offer.sdp);\n    }\n\n    // Set up event handlers BEFORE setRemoteDescription to avoid missing events\n    peerConnection.onicecandidate = function (e) {\n      if (e.candidate && e.candidate.candidate) {\n        // console.info(logHeader, 'Candidate Sent', '\\n', e.candidate.candidate, '\\n', e);\n        sendMessage(instance.webSocket, {\n          id: id,\n          peer_id: peerId,\n          command: 'candidate',\n          candidates: [e.candidate],\n        });\n      }\n    };\n\n    peerConnection.oniceconnectionstatechange = function (e) {\n      let state = peerConnection.iceConnectionState;\n\n      console.info(logHeader, 'ICE State', '[' + state + ']');\n      instance.iceLastEvent = e;\n\n      if (state === 'failed' && !instance.isManualStop) {\n        initRetryAfterLongEnoughIceDisconnect();\n      } else if (state === 'disconnected' && !instance.isManualStop) {\n        initRetryAfterLongEnoughIceDisconnect();\n      } else {\n        cancelRetryAfterLongEnoughIceDisconnect();\n      }\n      \n      if (instance.callbacks.iceStateChange) {\n        try {\n          instance.callbacks.iceStateChange(state);\n        } catch (callbackError) {\n          console.error(logHeader, 'Error in iceStateChange callback', callbackError);\n        }\n      }\n\n      if (state === 'connected') {\n        if (instance.callbacks.connected) {\n          try {\n            instance.callbacks.connected(e);\n          } catch (callbackError) {\n            console.error(logHeader, 'Error in connected callback', callbackError);\n          }\n        }\n      }\n\n      if (state === 'failed' || state === 'disconnected' || state === 'closed') {\n        if (instance.callbacks.connectionClosed) {\n          try {\n            instance.callbacks.connectionClosed('ice', e);\n          } catch (callbackError) {\n            console.error(logHeader, 'Error in connectionClosed callback', callbackError);\n          }\n        }\n      }\n    };\n\n    peerConnection.onconnectionstatechange = async function (e) {\n      let state = peerConnection.connectionState;\n\n      /* A happy ending! */\n      if (state === 'connected') {\n        instance.error = null;\n        instance.webSocketCloseEvent = null;\n        instance.reconnectWebSocketPromise = null;\n      }\n    };\n\n    await peerConnection.setRemoteDescription(offer);\n    const answer = await peerConnection.createAnswer();\n\n    if (checkIOSVersion() >= 15) {\n      const formatNumber = getFormatNumber(answer.sdp, 'H264');\n\n      if (formatNumber > 0) {\n        answer.sdp = removeFormat(answer.sdp, formatNumber);\n      }\n    }\n\n    if (instance.connectionConfig.sdp && instance.connectionConfig.sdp.appendFmtp) {\n      answer.sdp = appendFmtp(instance.connectionConfig.sdp.appendFmtp, answer.sdp);\n    }\n\n    await peerConnection.setLocalDescription(answer);\n\n    // Add remote ICE candidates after setRemoteDescription completes\n    if (candidates) {\n      await addIceCandidate(peerConnection, candidates);\n    }\n\n    sendMessage(instance.webSocket, {\n      id: id,\n      peer_id: peerId,\n      command: 'answer',\n      sdp: answer,\n    });\n  }\n\n  async function addIceCandidate(peerConnection, candidates) {\n    for (let i = 0; i < candidates.length; i++) {\n      if (candidates[i] && candidates[i].candidate) {\n        let basicCandidate = candidates[i];\n\n        try {\n          await peerConnection.addIceCandidate(new RTCIceCandidate(basicCandidate));\n        } catch (error) {\n          console.error('peerConnection.addIceCandidate', basicCandidate, error);\n          errorHandler(error);\n        }\n      }\n    }\n  }\n\n  // instance methods\n  instance.attachMedia = function (videoElement) {\n    instance.videoElement = videoElement;\n  };\n\n  instance.getUserMedia = function (constraints) {\n    return getUserMedia(constraints);\n  };\n\n  instance.getDisplayMedia = function (constraints) {\n    return getDisplayMedia(constraints);\n  };\n\n  instance.startStreaming = function (connectionUrl, connectionConfig) {\n    instance.connectionUrl = connectionUrl + '?direction=send&transport=tcp';\n    console.info(logEventHeader, 'Start Streaming');\n\n    if (connectionConfig) {\n      instance.connectionConfig = connectionConfig;\n    }\n\n    instance.retriesUsed = 0;\n    instance.isManualStop = false;\n    initWebSocket();\n  };\n\n  instance.closePeerConnection = function () {\n    cancelRetryAfterLongEnoughIceDisconnect();\n    // first release peer connection with ome\n    if (instance.peerConnection) {\n      // remove tracks from peer connection\n      instance.peerConnection.getSenders().forEach(function (sender) {\n        instance.peerConnection.removeTrack(sender);\n      });\n\n      instance.peerConnection.close();\n      instance.peerConnection = null;\n    }\n  };\n\n  instance.closeWebSocket = function () {\n    if (instance.webSocket && instance.webSocket.readyState !== WebSocket.CLOSED) {\n      // [FIX] Clear callback early to prevent retry trigger in onclose\n      instance.webSocket.onclose = null;\n      instance.webSocket.onerror = null;\n      instance.webSocket.onmessage = null;\n\n      if (instance.connectionData) {\n        sendMessage(instance.webSocket, {\n          id: instance.connectionData.id,\n          peer_id: instance.connectionData.peerId,\n          command: 'stop',\n        });\n      }\n\n      instance.webSocket.close();\n      instance.webSocket = null;\n    }\n  };\n\n  instance.closeVideoAudioStreams = function () {\n    if (instance.stream) {\n      instance.stream.getTracks().forEach((track) => {\n        track.stop();\n        instance.stream.removeTrack(track);\n      });\n\n      if (instance.videoElement) {\n        instance.videoElement.srcObject = null;\n      }\n\n      instance.stream = null;\n    }\n  };\n\n  instance.remove = function () {\n    instance.isManualStop = true;\n    instance.closePeerConnection();\n    instance.closeVideoAudioStreams();\n    instance.closeWebSocket();\n    console.info(logEventHeader, 'Removed');\n  };\n}\n\n// static methods\nQencodeWebRTC.create = function (config = {}) {\n  const instance = initConfig(config);\n  addMethod(instance);\n\n  return instance;\n};\n\nQencodeWebRTC.getDevices = async function () {\n  await getStreamForDeviceCheck();\n  const deviceInfos = await getDevices();\n  return gotDevices(deviceInfos);\n};\n\nexport default QencodeWebRTC;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","QencodeWebRTC","logHeader","logEventHeader","sendMessage","webSocket","message","readyState","WebSocket","OPEN","send","JSON","stringify","generateDomainFromUrl","url","match","result","findIp","string","RegExp","checkIOSVersion","agent","window","navigator","userAgent","start","indexOf","Number","substr","replace","splitSdpLines","sdp","split","map","line","joinSdpLines","lines","join","getFormatNumber","format","formatNumber","i","length","toLowerCase","removeFormat","newLines","push","delayedCall","fn","args","delay","Promise","resolve","setTimeout","then","appendFmtp","fmtpStr","payloads","tokens","j","fmtpLineFound","addMethod","instance","errorHandler","error","callbacks","callbackError","console","async","replaceTracksInPeerConnection","newStream","peerConnection","senders","getSenders","newTracks","getTracks","newVideoTrack","find","track","kind","newAudioTrack","sender","replaceTrack","info","requestOffer","command","offerRequestCount","addRetryToQueue","isManualStop","reconnectWebSocketPromise","retryDelay","reconnectWebSocket","onLine","log","addEventListener","once","connectStarted","disconnected","includes","iceConnectionState","isFinite","retryMaxCount","retriesUsed","closePeerConnection","closeWebSocket","webSocketCloseEvent","initWebSocket","e","connectionUrl","onopen","onmessage","parse","data","id","peerId","offer","candidates","iceServers","connectionData","peerConnectionConfig","connectionConfig","iceTransportPolicy","iceServer","regIceServer","urls","hasWebSocketUrl","webSocketUrl","cloneIceServer","ip","username","user_name","credential","RTCPeerConnection","stream","forEach","addTrack","maxVideoBitrate","media","bitrate","slice","concat","setBitrateLimit","onicecandidate","candidate","peer_id","oniceconnectionstatechange","state","iceLastEvent","timeout","iceDisconnectTimeoutId","initRetryAfterLongEnoughIceDisconnect","cancelRetryAfterLongEnoughIceDisconnect","iceStateChange","connected","connectionClosed","onconnectionstatechange","connectionState","setRemoteDescription","answer","createAnswer","setLocalDescription","basicCandidate","addIceCandidate","RTCIceCandidate","createPeerConnection","ice_servers","onerror","onclose","event","code","clearTimeout","attachMedia","videoElement","getUserMedia","constraints","video","deviceId","undefined","audio","mediaDevices","hasActiveConnection","oldStream","stop","elem","srcObject","onloadedmetadata","play","catch","getDisplayMedia","startStreaming","removeTrack","close","CLOSED","closeVideoAudioStreams","remove","create","config","initConfig","getDevices","width","ideal","height","getStreamForDeviceCheck","deviceInfos","devices","audioinput","audiooutput","videoinput","other","deviceInfo","label","gotDevices","enumerateDevices"],"sourceRoot":""}